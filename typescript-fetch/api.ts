/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Estuary API
 * This is the API for the Estuary application.
 *
 * OpenAPI spec version: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.estuary.tech".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface MainCollection
 */
export interface MainCollection {
    /**
     * 
     * @type {string}
     * @memberof MainCollection
     */
    cid?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCollection
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCollection
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCollection
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof MainCollection
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof MainCollection
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface MainCreateCollectionBody
 */
export interface MainCreateCollectionBody {
    /**
     * 
     * @type {string}
     * @memberof MainCreateCollectionBody
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof MainCreateCollectionBody
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface MainEstimateDealBody
 */
export interface MainEstimateDealBody {
    /**
     * 
     * @type {number}
     * @memberof MainEstimateDealBody
     */
    durationBlks?: number;
    /**
     * 
     * @type {number}
     * @memberof MainEstimateDealBody
     */
    replication?: number;
    /**
     * 
     * @type {number}
     * @memberof MainEstimateDealBody
     */
    size?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MainEstimateDealBody
     */
    verified?: boolean;
}

/**
 * 
 * @export
 * @interface MainGetApiKeysResp
 */
export interface MainGetApiKeysResp {
    /**
     * 
     * @type {string}
     * @memberof MainGetApiKeysResp
     */
    expiry?: string;
    /**
     * 
     * @type {string}
     * @memberof MainGetApiKeysResp
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface MainImportDealBody
 */
export interface MainImportDealBody {
    /**
     * 
     * @type {string}
     * @memberof MainImportDealBody
     */
    coluuid?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof MainImportDealBody
     */
    dealIDs?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof MainImportDealBody
     */
    dir?: string;
    /**
     * 
     * @type {string}
     * @memberof MainImportDealBody
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface MainUserStatsResponse
 */
export interface MainUserStatsResponse {
    /**
     * 
     * @type {number}
     * @memberof MainUserStatsResponse
     */
    numPins?: number;
    /**
     * 
     * @type {number}
     * @memberof MainUserStatsResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface UtilContentAddIpfsBody
 */
export interface UtilContentAddIpfsBody {
    /**
     * 
     * @type {string}
     * @memberof UtilContentAddIpfsBody
     */
    coluuid?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilContentAddIpfsBody
     */
    dir?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilContentAddIpfsBody
     */
    filename?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UtilContentAddIpfsBody
     */
    peers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UtilContentAddIpfsBody
     */
    root?: string;
}

/**
 * 
 * @export
 * @interface UtilContentAddResponse
 */
export interface UtilContentAddResponse {
    /**
     * 
     * @type {string}
     * @memberof UtilContentAddResponse
     */
    cid?: string;
    /**
     * 
     * @type {number}
     * @memberof UtilContentAddResponse
     */
    estuaryId?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UtilContentAddResponse
     */
    providers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UtilContentAddResponse
     */
    retrievalUrl?: string;
}

/**
 * 
 * @export
 * @interface UtilHttpError
 */
export interface UtilHttpError {
    /**
     * 
     * @type {number}
     * @memberof UtilHttpError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof UtilHttpError
     */
    details?: string;
    /**
     * 
     * @type {string}
     * @memberof UtilHttpError
     */
    reason?: string;
}


/**
 * AdminApi - fetch parameter creator
 * @export
 */
export const AdminApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/stop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get system configs.
         * @summary Get systems(estuary/shuttle) config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSystemConfigGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/system/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get all users.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).adminPeeringPeersDelete(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).adminPeeringPeersGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).adminPeeringPeersPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).adminPeeringStartPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).adminPeeringStatusGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).adminPeeringStopPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get system configs.
         * @summary Get systems(estuary/shuttle) config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSystemConfigGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).adminSystemConfigGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get all users.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).adminUsersGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options?: any) {
            return AdminApiFp(configuration).adminPeeringPeersDelete(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options?: any) {
            return AdminApiFp(configuration).adminPeeringPeersGet(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options?: any) {
            return AdminApiFp(configuration).adminPeeringPeersPost(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options?: any) {
            return AdminApiFp(configuration).adminPeeringStartPost(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options?: any) {
            return AdminApiFp(configuration).adminPeeringStatusGet(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options?: any) {
            return AdminApiFp(configuration).adminPeeringStopPost(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get system configs.
         * @summary Get systems(estuary/shuttle) config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSystemConfigGet(options?: any) {
            return AdminApiFp(configuration).adminSystemConfigGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get all users.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersGet(options?: any) {
            return AdminApiFp(configuration).adminUsersGet(options)(fetch, basePath);
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * This endpoint can be used to remove a Peer from the Peering Service
     * @summary Remove peers on Peering Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminPeeringPeersDelete(options?: any) {
        return AdminApiFp(this.configuration).adminPeeringPeersDelete(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to list all peers on Peering Service
     * @summary List all Peering peers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminPeeringPeersGet(options?: any) {
        return AdminApiFp(this.configuration).adminPeeringPeersGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to add a Peer from the Peering Service
     * @summary Add peers on Peering Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminPeeringPeersPost(options?: any) {
        return AdminApiFp(this.configuration).adminPeeringPeersPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to start the Peering Service
     * @summary Start Peering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminPeeringStartPost(options?: any) {
        return AdminApiFp(this.configuration).adminPeeringStartPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to check the Peering status
     * @summary Check Peering Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminPeeringStatusGet(options?: any) {
        return AdminApiFp(this.configuration).adminPeeringStatusGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to stop the Peering Service
     * @summary Stop Peering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminPeeringStopPost(options?: any) {
        return AdminApiFp(this.configuration).adminPeeringStopPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get system configs.
     * @summary Get systems(estuary/shuttle) config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminSystemConfigGet(options?: any) {
        return AdminApiFp(this.configuration).adminSystemConfigGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get all users.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersGet(options?: any) {
        return AdminApiFp(this.configuration).adminUsersGet(options)(this.fetch, this.basePath);
    }

}

/**
 * AutoretrieveApi - fetch parameter creator
 * @export
 */
export const AutoretrieveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint registers a new autoretrieve server
         * @summary Register autoretrieve server
         * @param {string} addresses Autoretrieve&#39;s comma-separated list of addresses
         * @param {string} pubKey Autoretrieve&#39;s public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAutoretrieveInitPost(addresses: string, pubKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'addresses' is not null or undefined
            if (addresses === null || addresses === undefined) {
                throw new RequiredError('addresses','Required parameter addresses was null or undefined when calling adminAutoretrieveInitPost.');
            }
            // verify required parameter 'pubKey' is not null or undefined
            if (pubKey === null || pubKey === undefined) {
                throw new RequiredError('pubKey','Required parameter pubKey was null or undefined when calling adminAutoretrieveInitPost.');
            }
            const localVarPath = `/admin/autoretrieve/init`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(pubKey || {}) : (pubKey || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists all registered autoretrieve servers
         * @summary List autoretrieve servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAutoretrieveListGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/autoretrieve/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates the lastConnection field for autoretrieve
         * @summary Marks autoretrieve server as up
         * @param {string} token Autoretrieve&#39;s auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoretrieveHeartbeatPost(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling autoretrieveHeartbeatPost.');
            }
            const localVarPath = `/autoretrieve/heartbeat`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (token !== undefined && token !== null) {
                localVarHeaderParameter['token'] = String(token);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoretrieveApi - functional programming interface
 * @export
 */
export const AutoretrieveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint registers a new autoretrieve server
         * @summary Register autoretrieve server
         * @param {string} addresses Autoretrieve&#39;s comma-separated list of addresses
         * @param {string} pubKey Autoretrieve&#39;s public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAutoretrieveInitPost(addresses: string, pubKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AutoretrieveApiFetchParamCreator(configuration).adminAutoretrieveInitPost(addresses, pubKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint lists all registered autoretrieve servers
         * @summary List autoretrieve servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAutoretrieveListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AutoretrieveApiFetchParamCreator(configuration).adminAutoretrieveListGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint updates the lastConnection field for autoretrieve
         * @summary Marks autoretrieve server as up
         * @param {string} token Autoretrieve&#39;s auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoretrieveHeartbeatPost(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AutoretrieveApiFetchParamCreator(configuration).autoretrieveHeartbeatPost(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AutoretrieveApi - factory interface
 * @export
 */
export const AutoretrieveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint registers a new autoretrieve server
         * @summary Register autoretrieve server
         * @param {string} addresses Autoretrieve&#39;s comma-separated list of addresses
         * @param {string} pubKey Autoretrieve&#39;s public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAutoretrieveInitPost(addresses: string, pubKey: string, options?: any) {
            return AutoretrieveApiFp(configuration).adminAutoretrieveInitPost(addresses, pubKey, options)(fetch, basePath);
        },
        /**
         * This endpoint lists all registered autoretrieve servers
         * @summary List autoretrieve servers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAutoretrieveListGet(options?: any) {
            return AutoretrieveApiFp(configuration).adminAutoretrieveListGet(options)(fetch, basePath);
        },
        /**
         * This endpoint updates the lastConnection field for autoretrieve
         * @summary Marks autoretrieve server as up
         * @param {string} token Autoretrieve&#39;s auth token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoretrieveHeartbeatPost(token: string, options?: any) {
            return AutoretrieveApiFp(configuration).autoretrieveHeartbeatPost(token, options)(fetch, basePath);
        },
    };
};

/**
 * AutoretrieveApi - object-oriented interface
 * @export
 * @class AutoretrieveApi
 * @extends {BaseAPI}
 */
export class AutoretrieveApi extends BaseAPI {
    /**
     * This endpoint registers a new autoretrieve server
     * @summary Register autoretrieve server
     * @param {string} addresses Autoretrieve&#39;s comma-separated list of addresses
     * @param {string} pubKey Autoretrieve&#39;s public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoretrieveApi
     */
    public adminAutoretrieveInitPost(addresses: string, pubKey: string, options?: any) {
        return AutoretrieveApiFp(this.configuration).adminAutoretrieveInitPost(addresses, pubKey, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint lists all registered autoretrieve servers
     * @summary List autoretrieve servers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoretrieveApi
     */
    public adminAutoretrieveListGet(options?: any) {
        return AutoretrieveApiFp(this.configuration).adminAutoretrieveListGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint updates the lastConnection field for autoretrieve
     * @summary Marks autoretrieve server as up
     * @param {string} token Autoretrieve&#39;s auth token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoretrieveApi
     */
    public autoretrieveHeartbeatPost(token: string, options?: any) {
        return AutoretrieveApiFp(this.configuration).autoretrieveHeartbeatPost(token, options)(this.fetch, this.basePath);
    }

}

/**
 * CollectionsApi - fetch parameter creator
 * @export
 */
export const CollectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to save the contents in a collection, producing a top-level CID that references all the current CIDs in the collection.
         * @summary Produce a CID of the collection contents
         * @param {string} coluuid coluuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidCommitPost(coluuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'coluuid' is not null or undefined
            if (coluuid === null || coluuid === undefined) {
                throw new RequiredError('coluuid','Required parameter coluuid was null or undefined when calling collectionsColuuidCommitPost.');
            }
            const localVarPath = `/collections/{coluuid}/commit`
                .replace(`{${"coluuid"}}`, encodeURIComponent(String(coluuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to delete an existing collection.
         * @summary Deletes a collection
         * @param {string} coluuid Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidDelete(coluuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'coluuid' is not null or undefined
            if (coluuid === null || coluuid === undefined) {
                throw new RequiredError('coluuid','Required parameter coluuid was null or undefined when calling collectionsColuuidDelete.');
            }
            const localVarPath = `/collections/{coluuid}`
                .replace(`{${"coluuid"}}`, encodeURIComponent(String(coluuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get contents in a collection. If no colpath query param is passed
         * @summary Get contents in a collection
         * @param {string} coluuid Collection UUID
         * @param {string} [dir] Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidGet(coluuid: string, dir?: string, options: any = {}): FetchArgs {
            // verify required parameter 'coluuid' is not null or undefined
            if (coluuid === null || coluuid === undefined) {
                throw new RequiredError('coluuid','Required parameter coluuid was null or undefined when calling collectionsColuuidGet.');
            }
            const localVarPath = `/collections/{coluuid}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (coluuid !== undefined) {
                localVarQueryParameter['coluuid'] = coluuid;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint adds already-pinned contents (that have ContentIDs) to a collection.
         * @summary Add contents to a collection
         * @param {Array<number>} body Content IDs to add to collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidPost(body: Array<number>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling collectionsColuuidPost.');
            }
            const localVarPath = `/collections/{coluuid}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint adds a file to a collection
         * @summary Add a file to a collection
         * @param {string} coluuid Collection ID
         * @param {string} content Content
         * @param {string} path Path to file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsFsAddPost(coluuid: string, content: string, path: string, options: any = {}): FetchArgs {
            // verify required parameter 'coluuid' is not null or undefined
            if (coluuid === null || coluuid === undefined) {
                throw new RequiredError('coluuid','Required parameter coluuid was null or undefined when calling collectionsFsAddPost.');
            }
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling collectionsFsAddPost.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling collectionsFsAddPost.');
            }
            const localVarPath = `/collections/fs/add`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (coluuid !== undefined) {
                localVarQueryParameter['coluuid'] = coluuid;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to list all collections. Whenever a user logs on estuary, it will list all collections that the user has access to. This endpoint provides a way to list all collections to the user.
         * @summary List all collections
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling collectionsGet.');
            }
            const localVarPath = `/collections/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to create a new collection. A collection is a representaion of a group of objects added on the estuary. This endpoint can be used to create a new collection.
         * @summary Create a new collection
         * @param {MainCreateCollectionBody} body Collection name and description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsPost(body: MainCreateCollectionBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling collectionsPost.');
            }
            const localVarPath = `/collections/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MainCreateCollectionBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to save the contents in a collection, producing a top-level CID that references all the current CIDs in the collection.
         * @summary Produce a CID of the collection contents
         * @param {string} coluuid coluuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidCommitPost(coluuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsColuuidCommitPost(coluuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to delete an existing collection.
         * @summary Deletes a collection
         * @param {string} coluuid Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidDelete(coluuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsColuuidDelete(coluuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get contents in a collection. If no colpath query param is passed
         * @summary Get contents in a collection
         * @param {string} coluuid Collection UUID
         * @param {string} [dir] Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidGet(coluuid: string, dir?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsColuuidGet(coluuid, dir, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint adds already-pinned contents (that have ContentIDs) to a collection.
         * @summary Add contents to a collection
         * @param {Array<number>} body Content IDs to add to collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidPost(body: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsColuuidPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint adds a file to a collection
         * @summary Add a file to a collection
         * @param {string} coluuid Collection ID
         * @param {string} content Content
         * @param {string} path Path to file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsFsAddPost(coluuid: string, content: string, path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsFsAddPost(coluuid, content, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to list all collections. Whenever a user logs on estuary, it will list all collections that the user has access to. This endpoint provides a way to list all collections to the user.
         * @summary List all collections
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MainCollection>> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to create a new collection. A collection is a representaion of a group of objects added on the estuary. This endpoint can be used to create a new collection.
         * @summary Create a new collection
         * @param {MainCreateCollectionBody} body Collection name and description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsPost(body: MainCreateCollectionBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MainCollection> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint is used to save the contents in a collection, producing a top-level CID that references all the current CIDs in the collection.
         * @summary Produce a CID of the collection contents
         * @param {string} coluuid coluuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidCommitPost(coluuid: string, options?: any) {
            return CollectionsApiFp(configuration).collectionsColuuidCommitPost(coluuid, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to delete an existing collection.
         * @summary Deletes a collection
         * @param {string} coluuid Collection ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidDelete(coluuid: string, options?: any) {
            return CollectionsApiFp(configuration).collectionsColuuidDelete(coluuid, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get contents in a collection. If no colpath query param is passed
         * @summary Get contents in a collection
         * @param {string} coluuid Collection UUID
         * @param {string} [dir] Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidGet(coluuid: string, dir?: string, options?: any) {
            return CollectionsApiFp(configuration).collectionsColuuidGet(coluuid, dir, options)(fetch, basePath);
        },
        /**
         * This endpoint adds already-pinned contents (that have ContentIDs) to a collection.
         * @summary Add contents to a collection
         * @param {Array<number>} body Content IDs to add to collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsColuuidPost(body: Array<number>, options?: any) {
            return CollectionsApiFp(configuration).collectionsColuuidPost(body, options)(fetch, basePath);
        },
        /**
         * This endpoint adds a file to a collection
         * @summary Add a file to a collection
         * @param {string} coluuid Collection ID
         * @param {string} content Content
         * @param {string} path Path to file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsFsAddPost(coluuid: string, content: string, path: string, options?: any) {
            return CollectionsApiFp(configuration).collectionsFsAddPost(coluuid, content, path, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to list all collections. Whenever a user logs on estuary, it will list all collections that the user has access to. This endpoint provides a way to list all collections to the user.
         * @summary List all collections
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsGet(id: number, options?: any) {
            return CollectionsApiFp(configuration).collectionsGet(id, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to create a new collection. A collection is a representaion of a group of objects added on the estuary. This endpoint can be used to create a new collection.
         * @summary Create a new collection
         * @param {MainCreateCollectionBody} body Collection name and description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsPost(body: MainCreateCollectionBody, options?: any) {
            return CollectionsApiFp(configuration).collectionsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * This endpoint is used to save the contents in a collection, producing a top-level CID that references all the current CIDs in the collection.
     * @summary Produce a CID of the collection contents
     * @param {string} coluuid coluuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsColuuidCommitPost(coluuid: string, options?: any) {
        return CollectionsApiFp(this.configuration).collectionsColuuidCommitPost(coluuid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to delete an existing collection.
     * @summary Deletes a collection
     * @param {string} coluuid Collection ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsColuuidDelete(coluuid: string, options?: any) {
        return CollectionsApiFp(this.configuration).collectionsColuuidDelete(coluuid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get contents in a collection. If no colpath query param is passed
     * @summary Get contents in a collection
     * @param {string} coluuid Collection UUID
     * @param {string} [dir] Directory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsColuuidGet(coluuid: string, dir?: string, options?: any) {
        return CollectionsApiFp(this.configuration).collectionsColuuidGet(coluuid, dir, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint adds already-pinned contents (that have ContentIDs) to a collection.
     * @summary Add contents to a collection
     * @param {Array<number>} body Content IDs to add to collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsColuuidPost(body: Array<number>, options?: any) {
        return CollectionsApiFp(this.configuration).collectionsColuuidPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint adds a file to a collection
     * @summary Add a file to a collection
     * @param {string} coluuid Collection ID
     * @param {string} content Content
     * @param {string} path Path to file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsFsAddPost(coluuid: string, content: string, path: string, options?: any) {
        return CollectionsApiFp(this.configuration).collectionsFsAddPost(coluuid, content, path, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to list all collections. Whenever a user logs on estuary, it will list all collections that the user has access to. This endpoint provides a way to list all collections to the user.
     * @summary List all collections
     * @param {number} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsGet(id: number, options?: any) {
        return CollectionsApiFp(this.configuration).collectionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to create a new collection. A collection is a representaion of a group of objects added on the estuary. This endpoint can be used to create a new collection.
     * @summary Create a new collection
     * @param {MainCreateCollectionBody} body Collection name and description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsPost(body: MainCreateCollectionBody, options?: any) {
        return CollectionsApiFp(this.configuration).collectionsPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ContentApi - fetch parameter creator
 * @export
 */
export const ContentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to add a car object to the network. The object can be a file or a directory.
         * @summary Add Car object
         * @param {string} body Car
         * @param {string} [filename] Filename
         * @param {string} [commp] Commp
         * @param {string} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddCarPost(body: string, filename?: string, commp?: string, size?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentAddCarPost.');
            }
            const localVarPath = `/content/add-car`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (commp !== undefined) {
                localVarQueryParameter['commp'] = commp;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to add an IPFS object to the network. The object can be a file or a directory.
         * @summary Add IPFS object
         * @param {UtilContentAddIpfsBody} body IPFS Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddIpfsPost(body: UtilContentAddIpfsBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentAddIpfsPost.');
            }
            const localVarPath = `/content/add-ipfs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UtilContentAddIpfsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to upload new content.
         * @summary Add new content
         * @param {any} file File to upload
         * @param {string} coluuid Collection UUID
         * @param {string} dir Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddPost(file: any, coluuid: string, dir: string, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling contentAddPost.');
            }
            // verify required parameter 'coluuid' is not null or undefined
            if (coluuid === null || coluuid === undefined) {
                throw new RequiredError('coluuid','Required parameter coluuid was null or undefined when calling contentAddPost.');
            }
            // verify required parameter 'dir' is not null or undefined
            if (dir === null || dir === undefined) {
                throw new RequiredError('dir','Required parameter dir was null or undefined when calling contentAddPost.');
            }
            const localVarPath = `/content/add`
                .replace(`{${"coluuid"}}`, encodeURIComponent(String(coluuid)))
                .replace(`{${"dir"}}`, encodeURIComponent(String(dir)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns aggregated content stats
         * @summary Get aggregated content stats
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAggregatedContentGet(content: string, options: any = {}): FetchArgs {
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling contentAggregatedContentGet.');
            }
            const localVarPath = `/content/aggregated/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get all deals for a user
         * @summary Get all deals for a user
         * @param {string} begin Begin
         * @param {string} duration Duration
         * @param {string} all All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAllDealsGet(begin: string, duration: string, all: string, options: any = {}): FetchArgs {
            // verify required parameter 'begin' is not null or undefined
            if (begin === null || begin === undefined) {
                throw new RequiredError('begin','Required parameter begin was null or undefined when calling contentAllDealsGet.');
            }
            // verify required parameter 'duration' is not null or undefined
            if (duration === null || duration === undefined) {
                throw new RequiredError('duration','Required parameter duration was null or undefined when calling contentAllDealsGet.');
            }
            // verify required parameter 'all' is not null or undefined
            if (all === null || all === undefined) {
                throw new RequiredError('all','Required parameter all was null or undefined when calling contentAllDealsGet.');
            }
            const localVarPath = `/content/all-deals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns content bandwidth
         * @summary Get content bandwidth
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBwUsageContentGet(content: string, options: any = {}): FetchArgs {
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling contentBwUsageContentGet.');
            }
            const localVarPath = `/content/bw-usage/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint adds a new content
         * @summary Add a new content
         * @param {string} body Content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCreatePost(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentCreatePost.');
            }
            const localVarPath = `/content/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists all content with deals
         * @summary Content with deals
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentDealsGet(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/content/deals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint ensures that the content is replicated to the specified number of providers
         * @summary Ensure Replication
         * @param {string} datacid Data CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentEnsureReplicationDatacidGet(datacid: string, options: any = {}): FetchArgs {
            // verify required parameter 'datacid' is not null or undefined
            if (datacid === null || datacid === undefined) {
                throw new RequiredError('datacid','Required parameter datacid was null or undefined when calling contentEnsureReplicationDatacidGet.');
            }
            const localVarPath = `/content/ensure-replication/{datacid}`
                .replace(`{${"datacid"}}`, encodeURIComponent(String(datacid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all failures for a content
         * @summary List all failures for a content
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentFailuresContentGet(content: string, options: any = {}): FetchArgs {
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling contentFailuresContentGet.');
            }
            const localVarPath = `/content/failures/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint imports a deal into the shuttle.
         * @summary Import a deal
         * @param {MainImportDealBody} body Import a deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentImportdealPost(body: MainImportDealBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentImportdealPost.');
            }
            const localVarPath = `/content/importdeal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MainImportDealBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists all content
         * @summary List all pinned content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentListGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint reads content from the blockstore
         * @summary Read content
         * @param {string} cont CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReadContGet(cont: string, options: any = {}): FetchArgs {
            // verify required parameter 'cont' is not null or undefined
            if (cont === null || cont === undefined) {
                throw new RequiredError('cont','Required parameter cont was null or undefined when calling contentReadContGet.');
            }
            const localVarPath = `/content/read/{cont}`
                .replace(`{${"cont"}}`, encodeURIComponent(String(cont)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get staging zone for user.
         * @summary Get staging zone for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStagingZonesGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/staging-zones`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get content statistics. Every content stored in the network (estuary) is tracked by a unique ID which can be used to get information about the content. This endpoint will allow the consumer to get the collected stats of a conten
         * @summary Get content statistics
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsGet(limit: string, options: any = {}): FetchArgs {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling contentStatsGet.');
            }
            const localVarPath = `/content/stats`
                .replace(`{${"limit"}}`, encodeURIComponent(String(limit)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the status of a content
         * @summary Content Status
         * @param {number} id Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatusIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contentStatusIdGet.');
            }
            const localVarPath = `/content/status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to add a car object to the network. The object can be a file or a directory.
         * @summary Add Car object
         * @param {string} body Car
         * @param {string} [filename] Filename
         * @param {string} [commp] Commp
         * @param {string} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddCarPost(body: string, filename?: string, commp?: string, size?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentAddCarPost(body, filename, commp, size, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to add an IPFS object to the network. The object can be a file or a directory.
         * @summary Add IPFS object
         * @param {UtilContentAddIpfsBody} body IPFS Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddIpfsPost(body: UtilContentAddIpfsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentAddIpfsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to upload new content.
         * @summary Add new content
         * @param {any} file File to upload
         * @param {string} coluuid Collection UUID
         * @param {string} dir Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddPost(file: any, coluuid: string, dir: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UtilContentAddResponse> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentAddPost(file, coluuid, dir, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns aggregated content stats
         * @summary Get aggregated content stats
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAggregatedContentGet(content: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentAggregatedContentGet(content, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get all deals for a user
         * @summary Get all deals for a user
         * @param {string} begin Begin
         * @param {string} duration Duration
         * @param {string} all All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAllDealsGet(begin: string, duration: string, all: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentAllDealsGet(begin, duration, all, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns content bandwidth
         * @summary Get content bandwidth
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBwUsageContentGet(content: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentBwUsageContentGet(content, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint adds a new content
         * @summary Add a new content
         * @param {string} body Content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCreatePost(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentCreatePost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint lists all content with deals
         * @summary Content with deals
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentDealsGet(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentDealsGet(limit, offset, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint ensures that the content is replicated to the specified number of providers
         * @summary Ensure Replication
         * @param {string} datacid Data CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentEnsureReplicationDatacidGet(datacid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentEnsureReplicationDatacidGet(datacid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns all failures for a content
         * @summary List all failures for a content
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentFailuresContentGet(content: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentFailuresContentGet(content, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint imports a deal into the shuttle.
         * @summary Import a deal
         * @param {MainImportDealBody} body Import a deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentImportdealPost(body: MainImportDealBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentImportdealPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint lists all content
         * @summary List all pinned content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentListGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint reads content from the blockstore
         * @summary Read content
         * @param {string} cont CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReadContGet(cont: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentReadContGet(cont, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get staging zone for user.
         * @summary Get staging zone for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStagingZonesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentStagingZonesGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get content statistics. Every content stored in the network (estuary) is tracked by a unique ID which can be used to get information about the content. This endpoint will allow the consumer to get the collected stats of a conten
         * @summary Get content statistics
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsGet(limit: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentStatsGet(limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the status of a content
         * @summary Content Status
         * @param {number} id Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatusIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).contentStatusIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint is used to add a car object to the network. The object can be a file or a directory.
         * @summary Add Car object
         * @param {string} body Car
         * @param {string} [filename] Filename
         * @param {string} [commp] Commp
         * @param {string} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddCarPost(body: string, filename?: string, commp?: string, size?: string, options?: any) {
            return ContentApiFp(configuration).contentAddCarPost(body, filename, commp, size, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to add an IPFS object to the network. The object can be a file or a directory.
         * @summary Add IPFS object
         * @param {UtilContentAddIpfsBody} body IPFS Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddIpfsPost(body: UtilContentAddIpfsBody, options?: any) {
            return ContentApiFp(configuration).contentAddIpfsPost(body, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to upload new content.
         * @summary Add new content
         * @param {any} file File to upload
         * @param {string} coluuid Collection UUID
         * @param {string} dir Directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAddPost(file: any, coluuid: string, dir: string, options?: any) {
            return ContentApiFp(configuration).contentAddPost(file, coluuid, dir, options)(fetch, basePath);
        },
        /**
         * This endpoint returns aggregated content stats
         * @summary Get aggregated content stats
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAggregatedContentGet(content: string, options?: any) {
            return ContentApiFp(configuration).contentAggregatedContentGet(content, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get all deals for a user
         * @summary Get all deals for a user
         * @param {string} begin Begin
         * @param {string} duration Duration
         * @param {string} all All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentAllDealsGet(begin: string, duration: string, all: string, options?: any) {
            return ContentApiFp(configuration).contentAllDealsGet(begin, duration, all, options)(fetch, basePath);
        },
        /**
         * This endpoint returns content bandwidth
         * @summary Get content bandwidth
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBwUsageContentGet(content: string, options?: any) {
            return ContentApiFp(configuration).contentBwUsageContentGet(content, options)(fetch, basePath);
        },
        /**
         * This endpoint adds a new content
         * @summary Add a new content
         * @param {string} body Content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentCreatePost(body: string, options?: any) {
            return ContentApiFp(configuration).contentCreatePost(body, options)(fetch, basePath);
        },
        /**
         * This endpoint lists all content with deals
         * @summary Content with deals
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentDealsGet(limit?: number, offset?: number, options?: any) {
            return ContentApiFp(configuration).contentDealsGet(limit, offset, options)(fetch, basePath);
        },
        /**
         * This endpoint ensures that the content is replicated to the specified number of providers
         * @summary Ensure Replication
         * @param {string} datacid Data CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentEnsureReplicationDatacidGet(datacid: string, options?: any) {
            return ContentApiFp(configuration).contentEnsureReplicationDatacidGet(datacid, options)(fetch, basePath);
        },
        /**
         * This endpoint returns all failures for a content
         * @summary List all failures for a content
         * @param {string} content Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentFailuresContentGet(content: string, options?: any) {
            return ContentApiFp(configuration).contentFailuresContentGet(content, options)(fetch, basePath);
        },
        /**
         * This endpoint imports a deal into the shuttle.
         * @summary Import a deal
         * @param {MainImportDealBody} body Import a deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentImportdealPost(body: MainImportDealBody, options?: any) {
            return ContentApiFp(configuration).contentImportdealPost(body, options)(fetch, basePath);
        },
        /**
         * This endpoint lists all content
         * @summary List all pinned content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentListGet(options?: any) {
            return ContentApiFp(configuration).contentListGet(options)(fetch, basePath);
        },
        /**
         * This endpoint reads content from the blockstore
         * @summary Read content
         * @param {string} cont CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentReadContGet(cont: string, options?: any) {
            return ContentApiFp(configuration).contentReadContGet(cont, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get staging zone for user.
         * @summary Get staging zone for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStagingZonesGet(options?: any) {
            return ContentApiFp(configuration).contentStagingZonesGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get content statistics. Every content stored in the network (estuary) is tracked by a unique ID which can be used to get information about the content. This endpoint will allow the consumer to get the collected stats of a conten
         * @summary Get content statistics
         * @param {string} limit limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatsGet(limit: string, options?: any) {
            return ContentApiFp(configuration).contentStatsGet(limit, options)(fetch, basePath);
        },
        /**
         * This endpoint returns the status of a content
         * @summary Content Status
         * @param {number} id Content ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentStatusIdGet(id: number, options?: any) {
            return ContentApiFp(configuration).contentStatusIdGet(id, options)(fetch, basePath);
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * This endpoint is used to add a car object to the network. The object can be a file or a directory.
     * @summary Add Car object
     * @param {string} body Car
     * @param {string} [filename] Filename
     * @param {string} [commp] Commp
     * @param {string} [size] Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentAddCarPost(body: string, filename?: string, commp?: string, size?: string, options?: any) {
        return ContentApiFp(this.configuration).contentAddCarPost(body, filename, commp, size, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to add an IPFS object to the network. The object can be a file or a directory.
     * @summary Add IPFS object
     * @param {UtilContentAddIpfsBody} body IPFS Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentAddIpfsPost(body: UtilContentAddIpfsBody, options?: any) {
        return ContentApiFp(this.configuration).contentAddIpfsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to upload new content.
     * @summary Add new content
     * @param {any} file File to upload
     * @param {string} coluuid Collection UUID
     * @param {string} dir Directory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentAddPost(file: any, coluuid: string, dir: string, options?: any) {
        return ContentApiFp(this.configuration).contentAddPost(file, coluuid, dir, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns aggregated content stats
     * @summary Get aggregated content stats
     * @param {string} content Content ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentAggregatedContentGet(content: string, options?: any) {
        return ContentApiFp(this.configuration).contentAggregatedContentGet(content, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get all deals for a user
     * @summary Get all deals for a user
     * @param {string} begin Begin
     * @param {string} duration Duration
     * @param {string} all All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentAllDealsGet(begin: string, duration: string, all: string, options?: any) {
        return ContentApiFp(this.configuration).contentAllDealsGet(begin, duration, all, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns content bandwidth
     * @summary Get content bandwidth
     * @param {string} content Content ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentBwUsageContentGet(content: string, options?: any) {
        return ContentApiFp(this.configuration).contentBwUsageContentGet(content, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint adds a new content
     * @summary Add a new content
     * @param {string} body Content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentCreatePost(body: string, options?: any) {
        return ContentApiFp(this.configuration).contentCreatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint lists all content with deals
     * @summary Content with deals
     * @param {number} [limit] Limit
     * @param {number} [offset] Offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentDealsGet(limit?: number, offset?: number, options?: any) {
        return ContentApiFp(this.configuration).contentDealsGet(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint ensures that the content is replicated to the specified number of providers
     * @summary Ensure Replication
     * @param {string} datacid Data CID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentEnsureReplicationDatacidGet(datacid: string, options?: any) {
        return ContentApiFp(this.configuration).contentEnsureReplicationDatacidGet(datacid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns all failures for a content
     * @summary List all failures for a content
     * @param {string} content Content ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentFailuresContentGet(content: string, options?: any) {
        return ContentApiFp(this.configuration).contentFailuresContentGet(content, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint imports a deal into the shuttle.
     * @summary Import a deal
     * @param {MainImportDealBody} body Import a deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentImportdealPost(body: MainImportDealBody, options?: any) {
        return ContentApiFp(this.configuration).contentImportdealPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint lists all content
     * @summary List all pinned content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentListGet(options?: any) {
        return ContentApiFp(this.configuration).contentListGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint reads content from the blockstore
     * @summary Read content
     * @param {string} cont CID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentReadContGet(cont: string, options?: any) {
        return ContentApiFp(this.configuration).contentReadContGet(cont, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get staging zone for user.
     * @summary Get staging zone for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentStagingZonesGet(options?: any) {
        return ContentApiFp(this.configuration).contentStagingZonesGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get content statistics. Every content stored in the network (estuary) is tracked by a unique ID which can be used to get information about the content. This endpoint will allow the consumer to get the collected stats of a conten
     * @summary Get content statistics
     * @param {string} limit limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentStatsGet(limit: string, options?: any) {
        return ContentApiFp(this.configuration).contentStatsGet(limit, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the status of a content
     * @summary Content Status
     * @param {number} id Content ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentStatusIdGet(id: number, options?: any) {
        return ContentApiFp(this.configuration).contentStatusIdGet(id, options)(this.fetch, this.basePath);
    }

}

/**
 * DealsApi - fetch parameter creator
 * @export
 */
export const DealsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint estimates the cost of a deal
         * @summary Estimate the cost of a deal
         * @param {MainEstimateDealBody} body The size of the deal in bytes, the replication factor, and the duration of the deal in blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealEstimatePost(body: MainEstimateDealBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dealEstimatePost.');
            }
            const localVarPath = `/deal/estimate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MainEstimateDealBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the deal info for a deal
         * @summary Get Deal Info
         * @param {number} dealid Deal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealInfoDealidGet(dealid: number, options: any = {}): FetchArgs {
            // verify required parameter 'dealid' is not null or undefined
            if (dealid === null || dealid === undefined) {
                throw new RequiredError('dealid','Required parameter dealid was null or undefined when calling dealInfoDealidGet.');
            }
            const localVarPath = `/deal/info/{dealid}`
                .replace(`{${"dealid"}}`, encodeURIComponent(String(dealid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the proposal for a deal
         * @summary Get Proposal
         * @param {string} propcid Proposal CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealProposalPropcidGet(propcid: string, options: any = {}): FetchArgs {
            // verify required parameter 'propcid' is not null or undefined
            if (propcid === null || propcid === undefined) {
                throw new RequiredError('propcid','Required parameter propcid was null or undefined when calling dealProposalPropcidGet.');
            }
            const localVarPath = `/deal/proposal/{propcid}`
                .replace(`{${"propcid"}}`, encodeURIComponent(String(propcid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the ask for a given CID
         * @summary Query Ask
         * @param {string} miner CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealQueryMinerGet(miner: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling dealQueryMinerGet.');
            }
            const localVarPath = `/deal/query/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Deal Status by PropCid
         * @summary Get Deal Status by PropCid
         * @param {string} propcid PropCid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealStatusByProposalPropcidGet(propcid: string, options: any = {}): FetchArgs {
            // verify required parameter 'propcid' is not null or undefined
            if (propcid === null || propcid === undefined) {
                throw new RequiredError('propcid','Required parameter propcid was null or undefined when calling dealStatusByProposalPropcidGet.');
            }
            const localVarPath = `/deal/status-by-proposal/{propcid}`
                .replace(`{${"propcid"}}`, encodeURIComponent(String(propcid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the status of a deal
         * @summary Deal Status
         * @param {string} miner Miner
         * @param {string} propcid Proposal CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealStatusMinerPropcidGet(miner: string, propcid: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling dealStatusMinerPropcidGet.');
            }
            // verify required parameter 'propcid' is not null or undefined
            if (propcid === null || propcid === undefined) {
                throw new RequiredError('propcid','Required parameter propcid was null or undefined when calling dealStatusMinerPropcidGet.');
            }
            const localVarPath = `/deal/status/{miner}/{propcid}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)))
                .replace(`{${"propcid"}}`, encodeURIComponent(String(propcid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the in-progress transfers
         * @summary Transfer In Progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealTransferInProgressGet(options: any = {}): FetchArgs {
            const localVarPath = `/deal/transfer/in-progress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the status of a transfer
         * @summary Transfer Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealTransferStatusPost(options: any = {}): FetchArgs {
            const localVarPath = `/deal/transfer/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of storage failures for user
         * @summary Get storage failures for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsFailuresGet(options: any = {}): FetchArgs {
            const localVarPath = `/deals/failures`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint makes a deal for a given content and miner
         * @summary Make Deal
         * @param {string} miner Miner
         * @param {string} dealRequest Deal Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsMakeMinerPost(miner: string, dealRequest: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling dealsMakeMinerPost.');
            }
            // verify required parameter 'dealRequest' is not null or undefined
            if (dealRequest === null || dealRequest === undefined) {
                throw new RequiredError('dealRequest','Required parameter dealRequest was null or undefined when calling dealsMakeMinerPost.');
            }
            const localVarPath = `/deals/make/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(dealRequest || {}) : (dealRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the status of a deal
         * @summary Get Deal Status
         * @param {number} deal Deal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsStatusDealGet(deal: number, options: any = {}): FetchArgs {
            // verify required parameter 'deal' is not null or undefined
            if (deal === null || deal === undefined) {
                throw new RequiredError('deal','Required parameter deal was null or undefined when calling dealsStatusDealGet.');
            }
            const localVarPath = `/deals/status/{deal}`
                .replace(`{${"deal"}}`, encodeURIComponent(String(deal)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of storage failures
         * @summary Get storage failures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicDealsFailuresGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/deals/failures`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the ask for a given CID
         * @summary Query Ask
         * @param {string} miner CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStorageQueryMinerGet(miner: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling publicMinersStorageQueryMinerGet.');
            }
            const localVarPath = `/public/miners/storage/query/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DealsApi - functional programming interface
 * @export
 */
export const DealsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint estimates the cost of a deal
         * @summary Estimate the cost of a deal
         * @param {MainEstimateDealBody} body The size of the deal in bytes, the replication factor, and the duration of the deal in blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealEstimatePost(body: MainEstimateDealBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealEstimatePost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the deal info for a deal
         * @summary Get Deal Info
         * @param {number} dealid Deal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealInfoDealidGet(dealid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealInfoDealidGet(dealid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the proposal for a deal
         * @summary Get Proposal
         * @param {string} propcid Proposal CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealProposalPropcidGet(propcid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealProposalPropcidGet(propcid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the ask for a given CID
         * @summary Query Ask
         * @param {string} miner CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealQueryMinerGet(miner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealQueryMinerGet(miner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Deal Status by PropCid
         * @summary Get Deal Status by PropCid
         * @param {string} propcid PropCid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealStatusByProposalPropcidGet(propcid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealStatusByProposalPropcidGet(propcid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the status of a deal
         * @summary Deal Status
         * @param {string} miner Miner
         * @param {string} propcid Proposal CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealStatusMinerPropcidGet(miner: string, propcid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealStatusMinerPropcidGet(miner, propcid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the in-progress transfers
         * @summary Transfer In Progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealTransferInProgressGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealTransferInProgressGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the status of a transfer
         * @summary Transfer Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealTransferStatusPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealTransferStatusPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns a list of storage failures for user
         * @summary Get storage failures for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsFailuresGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealsFailuresGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint makes a deal for a given content and miner
         * @summary Make Deal
         * @param {string} miner Miner
         * @param {string} dealRequest Deal Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsMakeMinerPost(miner: string, dealRequest: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealsMakeMinerPost(miner, dealRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the status of a deal
         * @summary Get Deal Status
         * @param {number} deal Deal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsStatusDealGet(deal: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).dealsStatusDealGet(deal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns a list of storage failures
         * @summary Get storage failures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicDealsFailuresGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).publicDealsFailuresGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns the ask for a given CID
         * @summary Query Ask
         * @param {string} miner CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStorageQueryMinerGet(miner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).publicMinersStorageQueryMinerGet(miner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DealsApi - factory interface
 * @export
 */
export const DealsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint estimates the cost of a deal
         * @summary Estimate the cost of a deal
         * @param {MainEstimateDealBody} body The size of the deal in bytes, the replication factor, and the duration of the deal in blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealEstimatePost(body: MainEstimateDealBody, options?: any) {
            return DealsApiFp(configuration).dealEstimatePost(body, options)(fetch, basePath);
        },
        /**
         * This endpoint returns the deal info for a deal
         * @summary Get Deal Info
         * @param {number} dealid Deal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealInfoDealidGet(dealid: number, options?: any) {
            return DealsApiFp(configuration).dealInfoDealidGet(dealid, options)(fetch, basePath);
        },
        /**
         * This endpoint returns the proposal for a deal
         * @summary Get Proposal
         * @param {string} propcid Proposal CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealProposalPropcidGet(propcid: string, options?: any) {
            return DealsApiFp(configuration).dealProposalPropcidGet(propcid, options)(fetch, basePath);
        },
        /**
         * This endpoint returns the ask for a given CID
         * @summary Query Ask
         * @param {string} miner CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealQueryMinerGet(miner: string, options?: any) {
            return DealsApiFp(configuration).dealQueryMinerGet(miner, options)(fetch, basePath);
        },
        /**
         * Get Deal Status by PropCid
         * @summary Get Deal Status by PropCid
         * @param {string} propcid PropCid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealStatusByProposalPropcidGet(propcid: string, options?: any) {
            return DealsApiFp(configuration).dealStatusByProposalPropcidGet(propcid, options)(fetch, basePath);
        },
        /**
         * This endpoint returns the status of a deal
         * @summary Deal Status
         * @param {string} miner Miner
         * @param {string} propcid Proposal CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealStatusMinerPropcidGet(miner: string, propcid: string, options?: any) {
            return DealsApiFp(configuration).dealStatusMinerPropcidGet(miner, propcid, options)(fetch, basePath);
        },
        /**
         * This endpoint returns the in-progress transfers
         * @summary Transfer In Progress
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealTransferInProgressGet(options?: any) {
            return DealsApiFp(configuration).dealTransferInProgressGet(options)(fetch, basePath);
        },
        /**
         * This endpoint returns the status of a transfer
         * @summary Transfer Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealTransferStatusPost(options?: any) {
            return DealsApiFp(configuration).dealTransferStatusPost(options)(fetch, basePath);
        },
        /**
         * This endpoint returns a list of storage failures for user
         * @summary Get storage failures for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsFailuresGet(options?: any) {
            return DealsApiFp(configuration).dealsFailuresGet(options)(fetch, basePath);
        },
        /**
         * This endpoint makes a deal for a given content and miner
         * @summary Make Deal
         * @param {string} miner Miner
         * @param {string} dealRequest Deal Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsMakeMinerPost(miner: string, dealRequest: string, options?: any) {
            return DealsApiFp(configuration).dealsMakeMinerPost(miner, dealRequest, options)(fetch, basePath);
        },
        /**
         * This endpoint returns the status of a deal
         * @summary Get Deal Status
         * @param {number} deal Deal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsStatusDealGet(deal: number, options?: any) {
            return DealsApiFp(configuration).dealsStatusDealGet(deal, options)(fetch, basePath);
        },
        /**
         * This endpoint returns a list of storage failures
         * @summary Get storage failures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicDealsFailuresGet(options?: any) {
            return DealsApiFp(configuration).publicDealsFailuresGet(options)(fetch, basePath);
        },
        /**
         * This endpoint returns the ask for a given CID
         * @summary Query Ask
         * @param {string} miner CID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStorageQueryMinerGet(miner: string, options?: any) {
            return DealsApiFp(configuration).publicMinersStorageQueryMinerGet(miner, options)(fetch, basePath);
        },
    };
};

/**
 * DealsApi - object-oriented interface
 * @export
 * @class DealsApi
 * @extends {BaseAPI}
 */
export class DealsApi extends BaseAPI {
    /**
     * This endpoint estimates the cost of a deal
     * @summary Estimate the cost of a deal
     * @param {MainEstimateDealBody} body The size of the deal in bytes, the replication factor, and the duration of the deal in blocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealEstimatePost(body: MainEstimateDealBody, options?: any) {
        return DealsApiFp(this.configuration).dealEstimatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the deal info for a deal
     * @summary Get Deal Info
     * @param {number} dealid Deal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealInfoDealidGet(dealid: number, options?: any) {
        return DealsApiFp(this.configuration).dealInfoDealidGet(dealid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the proposal for a deal
     * @summary Get Proposal
     * @param {string} propcid Proposal CID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealProposalPropcidGet(propcid: string, options?: any) {
        return DealsApiFp(this.configuration).dealProposalPropcidGet(propcid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the ask for a given CID
     * @summary Query Ask
     * @param {string} miner CID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealQueryMinerGet(miner: string, options?: any) {
        return DealsApiFp(this.configuration).dealQueryMinerGet(miner, options)(this.fetch, this.basePath);
    }

    /**
     * Get Deal Status by PropCid
     * @summary Get Deal Status by PropCid
     * @param {string} propcid PropCid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealStatusByProposalPropcidGet(propcid: string, options?: any) {
        return DealsApiFp(this.configuration).dealStatusByProposalPropcidGet(propcid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the status of a deal
     * @summary Deal Status
     * @param {string} miner Miner
     * @param {string} propcid Proposal CID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealStatusMinerPropcidGet(miner: string, propcid: string, options?: any) {
        return DealsApiFp(this.configuration).dealStatusMinerPropcidGet(miner, propcid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the in-progress transfers
     * @summary Transfer In Progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealTransferInProgressGet(options?: any) {
        return DealsApiFp(this.configuration).dealTransferInProgressGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the status of a transfer
     * @summary Transfer Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealTransferStatusPost(options?: any) {
        return DealsApiFp(this.configuration).dealTransferStatusPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns a list of storage failures for user
     * @summary Get storage failures for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealsFailuresGet(options?: any) {
        return DealsApiFp(this.configuration).dealsFailuresGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint makes a deal for a given content and miner
     * @summary Make Deal
     * @param {string} miner Miner
     * @param {string} dealRequest Deal Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealsMakeMinerPost(miner: string, dealRequest: string, options?: any) {
        return DealsApiFp(this.configuration).dealsMakeMinerPost(miner, dealRequest, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the status of a deal
     * @summary Get Deal Status
     * @param {number} deal Deal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public dealsStatusDealGet(deal: number, options?: any) {
        return DealsApiFp(this.configuration).dealsStatusDealGet(deal, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns a list of storage failures
     * @summary Get storage failures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public publicDealsFailuresGet(options?: any) {
        return DealsApiFp(this.configuration).publicDealsFailuresGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns the ask for a given CID
     * @summary Query Ask
     * @param {string} miner CID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public publicMinersStorageQueryMinerGet(miner: string, options?: any) {
        return DealsApiFp(this.configuration).publicMinersStorageQueryMinerGet(miner, options)(this.fetch, this.basePath);
    }

}

/**
 * MetricsApi - fetch parameter creator
 * @export
 */
export const MetricsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to get deal metrics
         * @summary Get deal metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMetricsDealsOnChainGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/metrics/deals-on-chain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to get deal metrics
         * @summary Get deal metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMetricsDealsOnChainGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).publicMetricsDealsOnChainGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint is used to get deal metrics
         * @summary Get deal metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMetricsDealsOnChainGet(options?: any) {
            return MetricsApiFp(configuration).publicMetricsDealsOnChainGet(options)(fetch, basePath);
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * This endpoint is used to get deal metrics
     * @summary Get deal metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public publicMetricsDealsOnChainGet(options?: any) {
        return MetricsApiFp(this.configuration).publicMetricsDealsOnChainGet(options)(this.fetch, this.basePath);
    }

}

/**
 * MinerApi - fetch parameter creator
 * @export
 */
export const MinerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns all miners deals
         * @summary Get all miners deals
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersDealsMinerGet(miner: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling publicMinersDealsMinerGet.');
            }
            const localVarPath = `/public/miners/deals/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns miner stats
         * @summary Get miner stats
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStatsMinerGet(miner: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling publicMinersStatsMinerGet.');
            }
            const localVarPath = `/public/miners/stats/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MinerApi - functional programming interface
 * @export
 */
export const MinerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint returns all miners deals
         * @summary Get all miners deals
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersDealsMinerGet(miner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MinerApiFetchParamCreator(configuration).publicMinersDealsMinerGet(miner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns miner stats
         * @summary Get miner stats
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStatsMinerGet(miner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MinerApiFetchParamCreator(configuration).publicMinersStatsMinerGet(miner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MinerApi - factory interface
 * @export
 */
export const MinerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint returns all miners deals
         * @summary Get all miners deals
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersDealsMinerGet(miner: string, options?: any) {
            return MinerApiFp(configuration).publicMinersDealsMinerGet(miner, options)(fetch, basePath);
        },
        /**
         * This endpoint returns miner stats
         * @summary Get miner stats
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStatsMinerGet(miner: string, options?: any) {
            return MinerApiFp(configuration).publicMinersStatsMinerGet(miner, options)(fetch, basePath);
        },
    };
};

/**
 * MinerApi - object-oriented interface
 * @export
 * @class MinerApi
 * @extends {BaseAPI}
 */
export class MinerApi extends BaseAPI {
    /**
     * This endpoint returns all miners deals
     * @summary Get all miners deals
     * @param {string} miner Filter by miner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MinerApi
     */
    public publicMinersDealsMinerGet(miner: string, options?: any) {
        return MinerApiFp(this.configuration).publicMinersDealsMinerGet(miner, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns miner stats
     * @summary Get miner stats
     * @param {string} miner Filter by miner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MinerApi
     */
    public publicMinersStatsMinerGet(miner: string, options?: any) {
        return MinerApiFp(this.configuration).publicMinersStatsMinerGet(miner, options)(this.fetch, this.basePath);
    }

}

/**
 * NetApi - fetch parameter creator
 * @export
 */
export const NetApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        netAddrsGet(options: any = {}): FetchArgs {
            const localVarPath = `/net/addrs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersFailuresMinerGet(miner: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling publicMinersFailuresMinerGet.');
            }
            const localVarPath = `/public/miners/failures/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/miners`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetAddrsGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/net/addrs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get net peers
         * @summary Net Peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetPeersGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/net/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetApi - functional programming interface
 * @export
 */
export const NetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        netAddrsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NetApiFetchParamCreator(configuration).netAddrsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersFailuresMinerGet(miner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NetApiFetchParamCreator(configuration).publicMinersFailuresMinerGet(miner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NetApiFetchParamCreator(configuration).publicMinersGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetAddrsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NetApiFetchParamCreator(configuration).publicNetAddrsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get net peers
         * @summary Net Peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetPeersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NetApiFetchParamCreator(configuration).publicNetPeersGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NetApi - factory interface
 * @export
 */
export const NetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        netAddrsGet(options?: any) {
            return NetApiFp(configuration).netAddrsGet(options)(fetch, basePath);
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersFailuresMinerGet(miner: string, options?: any) {
            return NetApiFp(configuration).publicMinersFailuresMinerGet(miner, options)(fetch, basePath);
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersGet(options?: any) {
            return NetApiFp(configuration).publicMinersGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetAddrsGet(options?: any) {
            return NetApiFp(configuration).publicNetAddrsGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get net peers
         * @summary Net Peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetPeersGet(options?: any) {
            return NetApiFp(configuration).publicNetPeersGet(options)(fetch, basePath);
        },
    };
};

/**
 * NetApi - object-oriented interface
 * @export
 * @class NetApi
 * @extends {BaseAPI}
 */
export class NetApi extends BaseAPI {
    /**
     * This endpoint is used to get net addrs
     * @summary Net Addrs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetApi
     */
    public netAddrsGet(options?: any) {
        return NetApiFp(this.configuration).netAddrsGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns all miners
     * @summary Get all miners
     * @param {string} miner Filter by miner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetApi
     */
    public publicMinersFailuresMinerGet(miner: string, options?: any) {
        return NetApiFp(this.configuration).publicMinersFailuresMinerGet(miner, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns all miners
     * @summary Get all miners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetApi
     */
    public publicMinersGet(options?: any) {
        return NetApiFp(this.configuration).publicMinersGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get net addrs
     * @summary Net Addrs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetApi
     */
    public publicNetAddrsGet(options?: any) {
        return NetApiFp(this.configuration).publicNetAddrsGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get net peers
     * @summary Net Peers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetApi
     */
    public publicNetPeersGet(options?: any) {
        return NetApiFp(this.configuration).publicNetPeersGet(options)(this.fetch, this.basePath);
    }

}

/**
 * PeeringApi - fetch parameter creator
 * @export
 */
export const PeeringApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/stop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeeringApi - functional programming interface
 * @export
 */
export const PeeringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeeringApiFetchParamCreator(configuration).adminPeeringPeersDelete(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeeringApiFetchParamCreator(configuration).adminPeeringPeersGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeeringApiFetchParamCreator(configuration).adminPeeringPeersPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeeringApiFetchParamCreator(configuration).adminPeeringStartPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeeringApiFetchParamCreator(configuration).adminPeeringStatusGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeeringApiFetchParamCreator(configuration).adminPeeringStopPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PeeringApi - factory interface
 * @export
 */
export const PeeringApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options?: any) {
            return PeeringApiFp(configuration).adminPeeringPeersDelete(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options?: any) {
            return PeeringApiFp(configuration).adminPeeringPeersGet(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options?: any) {
            return PeeringApiFp(configuration).adminPeeringPeersPost(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options?: any) {
            return PeeringApiFp(configuration).adminPeeringStartPost(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options?: any) {
            return PeeringApiFp(configuration).adminPeeringStatusGet(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options?: any) {
            return PeeringApiFp(configuration).adminPeeringStopPost(options)(fetch, basePath);
        },
    };
};

/**
 * PeeringApi - object-oriented interface
 * @export
 * @class PeeringApi
 * @extends {BaseAPI}
 */
export class PeeringApi extends BaseAPI {
    /**
     * This endpoint can be used to remove a Peer from the Peering Service
     * @summary Remove peers on Peering Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeeringApi
     */
    public adminPeeringPeersDelete(options?: any) {
        return PeeringApiFp(this.configuration).adminPeeringPeersDelete(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to list all peers on Peering Service
     * @summary List all Peering peers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeeringApi
     */
    public adminPeeringPeersGet(options?: any) {
        return PeeringApiFp(this.configuration).adminPeeringPeersGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to add a Peer from the Peering Service
     * @summary Add peers on Peering Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeeringApi
     */
    public adminPeeringPeersPost(options?: any) {
        return PeeringApiFp(this.configuration).adminPeeringPeersPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to start the Peering Service
     * @summary Start Peering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeeringApi
     */
    public adminPeeringStartPost(options?: any) {
        return PeeringApiFp(this.configuration).adminPeeringStartPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to check the Peering status
     * @summary Check Peering Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeeringApi
     */
    public adminPeeringStatusGet(options?: any) {
        return PeeringApiFp(this.configuration).adminPeeringStatusGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to stop the Peering Service
     * @summary Stop Peering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeeringApi
     */
    public adminPeeringStopPost(options?: any) {
        return PeeringApiFp(this.configuration).adminPeeringStopPost(options)(this.fetch, this.basePath);
    }

}

/**
 * PeersApi - fetch parameter creator
 * @export
 */
export const PeersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options: any = {}): FetchArgs {
            const localVarPath = `/admin/peering/stop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeersApi - functional programming interface
 * @export
 */
export const PeersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeersApiFetchParamCreator(configuration).adminPeeringPeersDelete(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeersApiFetchParamCreator(configuration).adminPeeringPeersGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeersApiFetchParamCreator(configuration).adminPeeringPeersPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeersApiFetchParamCreator(configuration).adminPeeringStartPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeersApiFetchParamCreator(configuration).adminPeeringStatusGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PeersApiFetchParamCreator(configuration).adminPeeringStopPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PeersApi - factory interface
 * @export
 */
export const PeersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint can be used to remove a Peer from the Peering Service
         * @summary Remove peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersDelete(options?: any) {
            return PeersApiFp(configuration).adminPeeringPeersDelete(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to list all peers on Peering Service
         * @summary List all Peering peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersGet(options?: any) {
            return PeersApiFp(configuration).adminPeeringPeersGet(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to add a Peer from the Peering Service
         * @summary Add peers on Peering Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringPeersPost(options?: any) {
            return PeersApiFp(configuration).adminPeeringPeersPost(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to start the Peering Service
         * @summary Start Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStartPost(options?: any) {
            return PeersApiFp(configuration).adminPeeringStartPost(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to check the Peering status
         * @summary Check Peering Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStatusGet(options?: any) {
            return PeersApiFp(configuration).adminPeeringStatusGet(options)(fetch, basePath);
        },
        /**
         * This endpoint can be used to stop the Peering Service
         * @summary Stop Peering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPeeringStopPost(options?: any) {
            return PeersApiFp(configuration).adminPeeringStopPost(options)(fetch, basePath);
        },
    };
};

/**
 * PeersApi - object-oriented interface
 * @export
 * @class PeersApi
 * @extends {BaseAPI}
 */
export class PeersApi extends BaseAPI {
    /**
     * This endpoint can be used to remove a Peer from the Peering Service
     * @summary Remove peers on Peering Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public adminPeeringPeersDelete(options?: any) {
        return PeersApiFp(this.configuration).adminPeeringPeersDelete(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to list all peers on Peering Service
     * @summary List all Peering peers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public adminPeeringPeersGet(options?: any) {
        return PeersApiFp(this.configuration).adminPeeringPeersGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to add a Peer from the Peering Service
     * @summary Add peers on Peering Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public adminPeeringPeersPost(options?: any) {
        return PeersApiFp(this.configuration).adminPeeringPeersPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to start the Peering Service
     * @summary Start Peering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public adminPeeringStartPost(options?: any) {
        return PeersApiFp(this.configuration).adminPeeringStartPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to check the Peering status
     * @summary Check Peering Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public adminPeeringStatusGet(options?: any) {
        return PeersApiFp(this.configuration).adminPeeringStatusGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint can be used to stop the Peering Service
     * @summary Stop Peering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeersApi
     */
    public adminPeeringStopPost(options?: any) {
        return PeersApiFp(this.configuration).adminPeeringStopPost(options)(this.fetch, this.basePath);
    }

}

/**
 * PinningApi - fetch parameter creator
 * @export
 */
export const PinningApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint lists all pin status objects
         * @summary List all pin status objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsGet(options: any = {}): FetchArgs {
            const localVarPath = `/pinning/pins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a pinned object.
         * @summary Delete a pinned object
         * @param {string} pinid Pin ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidDelete(pinid: string, options: any = {}): FetchArgs {
            // verify required parameter 'pinid' is not null or undefined
            if (pinid === null || pinid === undefined) {
                throw new RequiredError('pinid','Required parameter pinid was null or undefined when calling pinningPinsPinidDelete.');
            }
            const localVarPath = `/pinning/pins/{pinid}`
                .replace(`{${"pinid"}}`, encodeURIComponent(String(pinid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a pin status object.
         * @summary Get a pin status object
         * @param {string} pinid cid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidGet(pinid: string, options: any = {}): FetchArgs {
            // verify required parameter 'pinid' is not null or undefined
            if (pinid === null || pinid === undefined) {
                throw new RequiredError('pinid','Required parameter pinid was null or undefined when calling pinningPinsPinidGet.');
            }
            const localVarPath = `/pinning/pins/{pinid}`
                .replace(`{${"pinid"}}`, encodeURIComponent(String(pinid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint replaces a pinned object.
         * @summary Replace a pinned object
         * @param {string} pinid Pin ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidPost(pinid: string, options: any = {}): FetchArgs {
            // verify required parameter 'pinid' is not null or undefined
            if (pinid === null || pinid === undefined) {
                throw new RequiredError('pinid','Required parameter pinid was null or undefined when calling pinningPinsPinidPost.');
            }
            const localVarPath = `/pinning/pins/{pinid}`
                .replace(`{${"pinid"}}`, encodeURIComponent(String(pinid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint adds a pin to the IPFS daemon.
         * @summary Add and pin object
         * @param {string} cid cid
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPost(cid: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling pinningPinsPost.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling pinningPinsPost.');
            }
            const localVarPath = `/pinning/pins`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PinningApi - functional programming interface
 * @export
 */
export const PinningApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint lists all pin status objects
         * @summary List all pin status objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PinningApiFetchParamCreator(configuration).pinningPinsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint deletes a pinned object.
         * @summary Delete a pinned object
         * @param {string} pinid Pin ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidDelete(pinid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PinningApiFetchParamCreator(configuration).pinningPinsPinidDelete(pinid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns a pin status object.
         * @summary Get a pin status object
         * @param {string} pinid cid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidGet(pinid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PinningApiFetchParamCreator(configuration).pinningPinsPinidGet(pinid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint replaces a pinned object.
         * @summary Replace a pinned object
         * @param {string} pinid Pin ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidPost(pinid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PinningApiFetchParamCreator(configuration).pinningPinsPinidPost(pinid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint adds a pin to the IPFS daemon.
         * @summary Add and pin object
         * @param {string} cid cid
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPost(cid: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PinningApiFetchParamCreator(configuration).pinningPinsPost(cid, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PinningApi - factory interface
 * @export
 */
export const PinningApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint lists all pin status objects
         * @summary List all pin status objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsGet(options?: any) {
            return PinningApiFp(configuration).pinningPinsGet(options)(fetch, basePath);
        },
        /**
         * This endpoint deletes a pinned object.
         * @summary Delete a pinned object
         * @param {string} pinid Pin ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidDelete(pinid: string, options?: any) {
            return PinningApiFp(configuration).pinningPinsPinidDelete(pinid, options)(fetch, basePath);
        },
        /**
         * This endpoint returns a pin status object.
         * @summary Get a pin status object
         * @param {string} pinid cid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidGet(pinid: string, options?: any) {
            return PinningApiFp(configuration).pinningPinsPinidGet(pinid, options)(fetch, basePath);
        },
        /**
         * This endpoint replaces a pinned object.
         * @summary Replace a pinned object
         * @param {string} pinid Pin ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPinidPost(pinid: string, options?: any) {
            return PinningApiFp(configuration).pinningPinsPinidPost(pinid, options)(fetch, basePath);
        },
        /**
         * This endpoint adds a pin to the IPFS daemon.
         * @summary Add and pin object
         * @param {string} cid cid
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinningPinsPost(cid: string, name: string, options?: any) {
            return PinningApiFp(configuration).pinningPinsPost(cid, name, options)(fetch, basePath);
        },
    };
};

/**
 * PinningApi - object-oriented interface
 * @export
 * @class PinningApi
 * @extends {BaseAPI}
 */
export class PinningApi extends BaseAPI {
    /**
     * This endpoint lists all pin status objects
     * @summary List all pin status objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinningApi
     */
    public pinningPinsGet(options?: any) {
        return PinningApiFp(this.configuration).pinningPinsGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint deletes a pinned object.
     * @summary Delete a pinned object
     * @param {string} pinid Pin ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinningApi
     */
    public pinningPinsPinidDelete(pinid: string, options?: any) {
        return PinningApiFp(this.configuration).pinningPinsPinidDelete(pinid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns a pin status object.
     * @summary Get a pin status object
     * @param {string} pinid cid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinningApi
     */
    public pinningPinsPinidGet(pinid: string, options?: any) {
        return PinningApiFp(this.configuration).pinningPinsPinidGet(pinid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint replaces a pinned object.
     * @summary Replace a pinned object
     * @param {string} pinid Pin ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinningApi
     */
    public pinningPinsPinidPost(pinid: string, options?: any) {
        return PinningApiFp(this.configuration).pinningPinsPinidPost(pinid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint adds a pin to the IPFS daemon.
     * @summary Add and pin object
     * @param {string} cid cid
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinningApi
     */
    public pinningPinsPost(cid: string, name: string, options?: any) {
        return PinningApiFp(this.configuration).pinningPinsPost(cid, name, options)(this.fetch, this.basePath);
    }

}

/**
 * PublicApi - fetch parameter creator
 * @export
 */
export const PublicApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the content associated with a CID
         * @summary Get Content by Cid
         * @param {string} cid Cid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicByCidCidGet(cid: string, options: any = {}): FetchArgs {
            // verify required parameter 'cid' is not null or undefined
            if (cid === null || cid === undefined) {
                throw new RequiredError('cid','Required parameter cid was null or undefined when calling publicByCidCidGet.');
            }
            const localVarPath = `/public/by-cid/{cid}`
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about the node
         * @summary Get public node info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicInfoGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get deal metrics
         * @summary Get deal metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMetricsDealsOnChainGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/metrics/deals-on-chain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all miners deals
         * @summary Get all miners deals
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersDealsMinerGet(miner: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling publicMinersDealsMinerGet.');
            }
            const localVarPath = `/public/miners/deals/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersFailuresMinerGet(miner: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling publicMinersFailuresMinerGet.');
            }
            const localVarPath = `/public/miners/failures/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/miners`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns miner stats
         * @summary Get miner stats
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStatsMinerGet(miner: string, options: any = {}): FetchArgs {
            // verify required parameter 'miner' is not null or undefined
            if (miner === null || miner === undefined) {
                throw new RequiredError('miner','Required parameter miner was null or undefined when calling publicMinersStatsMinerGet.');
            }
            const localVarPath = `/public/miners/stats/{miner}`
                .replace(`{${"miner"}}`, encodeURIComponent(String(miner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetAddrsGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/net/addrs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get net peers
         * @summary Net Peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetPeersGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/net/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get public stats.
         * @summary Public stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicStatsGet(options: any = {}): FetchArgs {
            const localVarPath = `/public/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the content associated with a CID
         * @summary Get Content by Cid
         * @param {string} cid Cid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicByCidCidGet(cid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicByCidCidGet(cid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns information about the node
         * @summary Get public node info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicInfoGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicInfoGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get deal metrics
         * @summary Get deal metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMetricsDealsOnChainGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicMetricsDealsOnChainGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns all miners deals
         * @summary Get all miners deals
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersDealsMinerGet(miner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicMinersDealsMinerGet(miner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersFailuresMinerGet(miner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicMinersFailuresMinerGet(miner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicMinersGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns miner stats
         * @summary Get miner stats
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStatsMinerGet(miner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicMinersStatsMinerGet(miner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetAddrsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicNetAddrsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get net peers
         * @summary Net Peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetPeersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicNetPeersGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get public stats.
         * @summary Public stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicStatsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PublicApiFetchParamCreator(configuration).publicStatsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint returns the content associated with a CID
         * @summary Get Content by Cid
         * @param {string} cid Cid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicByCidCidGet(cid: string, options?: any) {
            return PublicApiFp(configuration).publicByCidCidGet(cid, options)(fetch, basePath);
        },
        /**
         * This endpoint returns information about the node
         * @summary Get public node info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicInfoGet(options?: any) {
            return PublicApiFp(configuration).publicInfoGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get deal metrics
         * @summary Get deal metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMetricsDealsOnChainGet(options?: any) {
            return PublicApiFp(configuration).publicMetricsDealsOnChainGet(options)(fetch, basePath);
        },
        /**
         * This endpoint returns all miners deals
         * @summary Get all miners deals
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersDealsMinerGet(miner: string, options?: any) {
            return PublicApiFp(configuration).publicMinersDealsMinerGet(miner, options)(fetch, basePath);
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersFailuresMinerGet(miner: string, options?: any) {
            return PublicApiFp(configuration).publicMinersFailuresMinerGet(miner, options)(fetch, basePath);
        },
        /**
         * This endpoint returns all miners
         * @summary Get all miners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersGet(options?: any) {
            return PublicApiFp(configuration).publicMinersGet(options)(fetch, basePath);
        },
        /**
         * This endpoint returns miner stats
         * @summary Get miner stats
         * @param {string} miner Filter by miner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicMinersStatsMinerGet(miner: string, options?: any) {
            return PublicApiFp(configuration).publicMinersStatsMinerGet(miner, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get net addrs
         * @summary Net Addrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetAddrsGet(options?: any) {
            return PublicApiFp(configuration).publicNetAddrsGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get net peers
         * @summary Net Peers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicNetPeersGet(options?: any) {
            return PublicApiFp(configuration).publicNetPeersGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get public stats.
         * @summary Public stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicStatsGet(options?: any) {
            return PublicApiFp(configuration).publicStatsGet(options)(fetch, basePath);
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * This endpoint returns the content associated with a CID
     * @summary Get Content by Cid
     * @param {string} cid Cid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicByCidCidGet(cid: string, options?: any) {
        return PublicApiFp(this.configuration).publicByCidCidGet(cid, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns information about the node
     * @summary Get public node info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicInfoGet(options?: any) {
        return PublicApiFp(this.configuration).publicInfoGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get deal metrics
     * @summary Get deal metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicMetricsDealsOnChainGet(options?: any) {
        return PublicApiFp(this.configuration).publicMetricsDealsOnChainGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns all miners deals
     * @summary Get all miners deals
     * @param {string} miner Filter by miner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicMinersDealsMinerGet(miner: string, options?: any) {
        return PublicApiFp(this.configuration).publicMinersDealsMinerGet(miner, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns all miners
     * @summary Get all miners
     * @param {string} miner Filter by miner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicMinersFailuresMinerGet(miner: string, options?: any) {
        return PublicApiFp(this.configuration).publicMinersFailuresMinerGet(miner, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns all miners
     * @summary Get all miners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicMinersGet(options?: any) {
        return PublicApiFp(this.configuration).publicMinersGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns miner stats
     * @summary Get miner stats
     * @param {string} miner Filter by miner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicMinersStatsMinerGet(miner: string, options?: any) {
        return PublicApiFp(this.configuration).publicMinersStatsMinerGet(miner, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get net addrs
     * @summary Net Addrs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicNetAddrsGet(options?: any) {
        return PublicApiFp(this.configuration).publicNetAddrsGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get net peers
     * @summary Net Peers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicNetPeersGet(options?: any) {
        return PublicApiFp(this.configuration).publicNetPeersGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get public stats.
     * @summary Public stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public publicStatsGet(options?: any) {
        return PublicApiFp(this.configuration).publicStatsGet(options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to get API keys for a user. In estuary, each user can be given multiple API keys (tokens). This endpoint can be used to retrieve all available API keys for a given user.
         * @summary Get API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/api-keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to revoke a user API key. In estuary, every user is assigned with an API key, this API key is generated and issued for each user and is primarily use to access all estuary features. This endpoint can be used to revoke the API key thats assigned to the user.
         * @summary Revoke a User API Key.
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysKeyDelete(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling userApiKeysKeyDelete.');
            }
            const localVarPath = `/user/api-keys/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to create API keys for a user. In estuary, each user is given an API key to access all features.
         * @summary Create API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysPost(options: any = {}): FetchArgs {
            const localVarPath = `/user/api-keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to get API keys for a user.
         * @summary Export user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExportGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/export`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to create API keys for a user.
         * @summary Create API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStatsGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to get API keys for a user. In estuary, each user can be given multiple API keys (tokens). This endpoint can be used to retrieve all available API keys for a given user.
         * @summary Get API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MainGetApiKeysResp>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userApiKeysGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to revoke a user API key. In estuary, every user is assigned with an API key, this API key is generated and issued for each user and is primarily use to access all estuary features. This endpoint can be used to revoke the API key thats assigned to the user.
         * @summary Revoke a User API Key.
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysKeyDelete(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userApiKeysKeyDelete(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to create API keys for a user. In estuary, each user is given an API key to access all features.
         * @summary Create API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MainGetApiKeysResp> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userApiKeysPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to get API keys for a user.
         * @summary Export user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExportGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userExportGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to create API keys for a user.
         * @summary Create API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStatsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MainUserStatsResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userStatsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint is used to get API keys for a user. In estuary, each user can be given multiple API keys (tokens). This endpoint can be used to retrieve all available API keys for a given user.
         * @summary Get API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysGet(options?: any) {
            return UserApiFp(configuration).userApiKeysGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to revoke a user API key. In estuary, every user is assigned with an API key, this API key is generated and issued for each user and is primarily use to access all estuary features. This endpoint can be used to revoke the API key thats assigned to the user.
         * @summary Revoke a User API Key.
         * @param {string} key Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysKeyDelete(key: string, options?: any) {
            return UserApiFp(configuration).userApiKeysKeyDelete(key, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to create API keys for a user. In estuary, each user is given an API key to access all features.
         * @summary Create API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userApiKeysPost(options?: any) {
            return UserApiFp(configuration).userApiKeysPost(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to get API keys for a user.
         * @summary Export user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExportGet(options?: any) {
            return UserApiFp(configuration).userExportGet(options)(fetch, basePath);
        },
        /**
         * This endpoint is used to create API keys for a user.
         * @summary Create API keys for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStatsGet(options?: any) {
            return UserApiFp(configuration).userStatsGet(options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * This endpoint is used to get API keys for a user. In estuary, each user can be given multiple API keys (tokens). This endpoint can be used to retrieve all available API keys for a given user.
     * @summary Get API keys for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userApiKeysGet(options?: any) {
        return UserApiFp(this.configuration).userApiKeysGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to revoke a user API key. In estuary, every user is assigned with an API key, this API key is generated and issued for each user and is primarily use to access all estuary features. This endpoint can be used to revoke the API key thats assigned to the user.
     * @summary Revoke a User API Key.
     * @param {string} key Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userApiKeysKeyDelete(key: string, options?: any) {
        return UserApiFp(this.configuration).userApiKeysKeyDelete(key, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to create API keys for a user. In estuary, each user is given an API key to access all features.
     * @summary Create API keys for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userApiKeysPost(options?: any) {
        return UserApiFp(this.configuration).userApiKeysPost(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to get API keys for a user.
     * @summary Export user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userExportGet(options?: any) {
        return UserApiFp(this.configuration).userExportGet(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to create API keys for a user.
     * @summary Create API keys for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userStatsGet(options?: any) {
        return UserApiFp(this.configuration).userStatsGet(options)(this.fetch, this.basePath);
    }

}

