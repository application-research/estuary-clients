{-
   Estuary API

   This is the API for the Estuary application.

   OpenAPI spec version: 2.0
   Estuary API API version: 0.0.0
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : Estuary.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Estuary.Model where

import Estuary.Core
import Estuary.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Addresses
newtype Addresses = Addresses { unAddresses :: Text } deriving (P.Eq, P.Show)

-- ** All
newtype All = All { unAll :: Text } deriving (P.Eq, P.Show)

-- ** Begin
newtype Begin = Begin { unBegin :: Text } deriving (P.Eq, P.Show)

-- ** Body2
newtype Body2 = Body2 { unBody2 :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Cid
newtype Cid = Cid { unCid :: Text } deriving (P.Eq, P.Show)

-- ** Coluuid
newtype Coluuid = Coluuid { unColuuid :: Text } deriving (P.Eq, P.Show)

-- ** Cont
newtype Cont = Cont { unCont :: Text } deriving (P.Eq, P.Show)

-- ** Content
newtype Content = Content { unContent :: Text } deriving (P.Eq, P.Show)

-- ** ContentIDs
newtype ContentIDs = ContentIDs { unContentIDs :: [Int] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Contentid
newtype Contentid = Contentid { unContentid :: Text } deriving (P.Eq, P.Show)

-- ** Datacid
newtype Datacid = Datacid { unDatacid :: Text } deriving (P.Eq, P.Show)

-- ** Deal
newtype Deal = Deal { unDeal :: Int } deriving (P.Eq, P.Show)

-- ** DealRequest2
newtype DealRequest2 = DealRequest2 { unDealRequest2 :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Dealid
newtype Dealid = Dealid { unDealid :: Int } deriving (P.Eq, P.Show)

-- ** Dir
newtype Dir = Dir { unDir :: Text } deriving (P.Eq, P.Show)

-- ** Duration
newtype Duration = Duration { unDuration :: Text } deriving (P.Eq, P.Show)

-- ** Expiry
newtype Expiry = Expiry { unExpiry :: Text } deriving (P.Eq, P.Show)

-- ** Filename
newtype Filename = Filename { unFilename :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** IgnoreDupes
newtype IgnoreDupes = IgnoreDupes { unIgnoreDupes :: Text } deriving (P.Eq, P.Show)

-- ** IgnoreFailed
newtype IgnoreFailed = IgnoreFailed { unIgnoreFailed :: Text } deriving (P.Eq, P.Show)

-- ** KeyOrHash
newtype KeyOrHash = KeyOrHash { unKeyOrHash :: Text } deriving (P.Eq, P.Show)

-- ** LazyProvide
newtype LazyProvide = LazyProvide { unLazyProvide :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** LimitText
newtype LimitText = LimitText { unLimitText :: Text } deriving (P.Eq, P.Show)

-- ** Miner
newtype Miner = Miner { unMiner :: Text } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** OffsetText
newtype OffsetText = OffsetText { unOffsetText :: Text } deriving (P.Eq, P.Show)

-- ** ParamData
newtype ParamData = ParamData { unParamData :: FilePath } deriving (P.Eq, P.Show)

-- ** Path
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)

-- ** PeerIds
newtype PeerIds = PeerIds { unPeerIds :: [Bool] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Perms
newtype Perms = Perms { unPerms :: Text } deriving (P.Eq, P.Show)

-- ** Pinid
newtype Pinid = Pinid { unPinid :: Text } deriving (P.Eq, P.Show)

-- ** Propcid
newtype Propcid = Propcid { unPropcid :: Text } deriving (P.Eq, P.Show)

-- ** PubKey
newtype PubKey = PubKey { unPubKey :: Text } deriving (P.Eq, P.Show)

-- ** Replication
newtype Replication = Replication { unReplication :: Int } deriving (P.Eq, P.Show)

-- ** Token
newtype Token = Token { unToken :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** CollectionsCollection
-- | CollectionsCollection
data CollectionsCollection = CollectionsCollection
  { collectionsCollectionCid :: !(Maybe Text) -- ^ "cid"
  , collectionsCollectionCreatedAt :: !(Maybe Text) -- ^ "createdAt"
  , collectionsCollectionDescription :: !(Maybe Text) -- ^ "description"
  , collectionsCollectionName :: !(Maybe Text) -- ^ "name"
  , collectionsCollectionUserId :: !(Maybe Int) -- ^ "userId"
  , collectionsCollectionUuid :: !(Maybe Text) -- ^ "uuid"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CollectionsCollection
instance A.FromJSON CollectionsCollection where
  parseJSON = A.withObject "CollectionsCollection" $ \o ->
    CollectionsCollection
      <$> (o .:? "cid")
      <*> (o .:? "createdAt")
      <*> (o .:? "description")
      <*> (o .:? "name")
      <*> (o .:? "userId")
      <*> (o .:? "uuid")

-- | ToJSON CollectionsCollection
instance A.ToJSON CollectionsCollection where
  toJSON CollectionsCollection {..} =
   _omitNulls
      [ "cid" .= collectionsCollectionCid
      , "createdAt" .= collectionsCollectionCreatedAt
      , "description" .= collectionsCollectionDescription
      , "name" .= collectionsCollectionName
      , "userId" .= collectionsCollectionUserId
      , "uuid" .= collectionsCollectionUuid
      ]


-- | Construct a value of type 'CollectionsCollection' (by applying it's required fields, if any)
mkCollectionsCollection
  :: CollectionsCollection
mkCollectionsCollection =
  CollectionsCollection
  { collectionsCollectionCid = Nothing
  , collectionsCollectionCreatedAt = Nothing
  , collectionsCollectionDescription = Nothing
  , collectionsCollectionName = Nothing
  , collectionsCollectionUserId = Nothing
  , collectionsCollectionUuid = Nothing
  }

-- ** MainChannelIDParam
-- | MainChannelIDParam
data MainChannelIDParam = MainChannelIDParam
  { mainChannelIDParamId :: !(Maybe Int) -- ^ "id"
  , mainChannelIDParamInitiator :: !(Maybe Text) -- ^ "initiator"
  , mainChannelIDParamResponder :: !(Maybe Text) -- ^ "responder"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MainChannelIDParam
instance A.FromJSON MainChannelIDParam where
  parseJSON = A.withObject "MainChannelIDParam" $ \o ->
    MainChannelIDParam
      <$> (o .:? "id")
      <*> (o .:? "initiator")
      <*> (o .:? "responder")

-- | ToJSON MainChannelIDParam
instance A.ToJSON MainChannelIDParam where
  toJSON MainChannelIDParam {..} =
   _omitNulls
      [ "id" .= mainChannelIDParamId
      , "initiator" .= mainChannelIDParamInitiator
      , "responder" .= mainChannelIDParamResponder
      ]


-- | Construct a value of type 'MainChannelIDParam' (by applying it's required fields, if any)
mkMainChannelIDParam
  :: MainChannelIDParam
mkMainChannelIDParam =
  MainChannelIDParam
  { mainChannelIDParamId = Nothing
  , mainChannelIDParamInitiator = Nothing
  , mainChannelIDParamResponder = Nothing
  }

-- ** MainCreateCollectionBody
-- | MainCreateCollectionBody
data MainCreateCollectionBody = MainCreateCollectionBody
  { mainCreateCollectionBodyDescription :: !(Maybe Text) -- ^ "description"
  , mainCreateCollectionBodyName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MainCreateCollectionBody
instance A.FromJSON MainCreateCollectionBody where
  parseJSON = A.withObject "MainCreateCollectionBody" $ \o ->
    MainCreateCollectionBody
      <$> (o .:? "description")
      <*> (o .:? "name")

-- | ToJSON MainCreateCollectionBody
instance A.ToJSON MainCreateCollectionBody where
  toJSON MainCreateCollectionBody {..} =
   _omitNulls
      [ "description" .= mainCreateCollectionBodyDescription
      , "name" .= mainCreateCollectionBodyName
      ]


-- | Construct a value of type 'MainCreateCollectionBody' (by applying it's required fields, if any)
mkMainCreateCollectionBody
  :: MainCreateCollectionBody
mkMainCreateCollectionBody =
  MainCreateCollectionBody
  { mainCreateCollectionBodyDescription = Nothing
  , mainCreateCollectionBodyName = Nothing
  }

-- ** MainDeleteContentFromCollectionBody
-- | MainDeleteContentFromCollectionBody
data MainDeleteContentFromCollectionBody = MainDeleteContentFromCollectionBody
  { mainDeleteContentFromCollectionBodyBy :: !(Maybe Text) -- ^ "by"
  , mainDeleteContentFromCollectionBodyValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MainDeleteContentFromCollectionBody
instance A.FromJSON MainDeleteContentFromCollectionBody where
  parseJSON = A.withObject "MainDeleteContentFromCollectionBody" $ \o ->
    MainDeleteContentFromCollectionBody
      <$> (o .:? "by")
      <*> (o .:? "value")

-- | ToJSON MainDeleteContentFromCollectionBody
instance A.ToJSON MainDeleteContentFromCollectionBody where
  toJSON MainDeleteContentFromCollectionBody {..} =
   _omitNulls
      [ "by" .= mainDeleteContentFromCollectionBodyBy
      , "value" .= mainDeleteContentFromCollectionBodyValue
      ]


-- | Construct a value of type 'MainDeleteContentFromCollectionBody' (by applying it's required fields, if any)
mkMainDeleteContentFromCollectionBody
  :: MainDeleteContentFromCollectionBody
mkMainDeleteContentFromCollectionBody =
  MainDeleteContentFromCollectionBody
  { mainDeleteContentFromCollectionBodyBy = Nothing
  , mainDeleteContentFromCollectionBodyValue = Nothing
  }

-- ** MainEstimateDealBody
-- | MainEstimateDealBody
data MainEstimateDealBody = MainEstimateDealBody
  { mainEstimateDealBodyDurationBlks :: !(Maybe Int) -- ^ "durationBlks"
  , mainEstimateDealBodyReplication :: !(Maybe Int) -- ^ "replication"
  , mainEstimateDealBodySize :: !(Maybe Int) -- ^ "size"
  , mainEstimateDealBodyVerified :: !(Maybe Bool) -- ^ "verified"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MainEstimateDealBody
instance A.FromJSON MainEstimateDealBody where
  parseJSON = A.withObject "MainEstimateDealBody" $ \o ->
    MainEstimateDealBody
      <$> (o .:? "durationBlks")
      <*> (o .:? "replication")
      <*> (o .:? "size")
      <*> (o .:? "verified")

-- | ToJSON MainEstimateDealBody
instance A.ToJSON MainEstimateDealBody where
  toJSON MainEstimateDealBody {..} =
   _omitNulls
      [ "durationBlks" .= mainEstimateDealBodyDurationBlks
      , "replication" .= mainEstimateDealBodyReplication
      , "size" .= mainEstimateDealBodySize
      , "verified" .= mainEstimateDealBodyVerified
      ]


-- | Construct a value of type 'MainEstimateDealBody' (by applying it's required fields, if any)
mkMainEstimateDealBody
  :: MainEstimateDealBody
mkMainEstimateDealBody =
  MainEstimateDealBody
  { mainEstimateDealBodyDurationBlks = Nothing
  , mainEstimateDealBodyReplication = Nothing
  , mainEstimateDealBodySize = Nothing
  , mainEstimateDealBodyVerified = Nothing
  }

-- ** MainGetApiKeysResp
-- | MainGetApiKeysResp
data MainGetApiKeysResp = MainGetApiKeysResp
  { mainGetApiKeysRespExpiry :: !(Maybe Text) -- ^ "expiry"
  , mainGetApiKeysRespLabel :: !(Maybe Text) -- ^ "label"
  , mainGetApiKeysRespToken :: !(Maybe Text) -- ^ "token"
  , mainGetApiKeysRespTokenHash :: !(Maybe Text) -- ^ "tokenHash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MainGetApiKeysResp
instance A.FromJSON MainGetApiKeysResp where
  parseJSON = A.withObject "MainGetApiKeysResp" $ \o ->
    MainGetApiKeysResp
      <$> (o .:? "expiry")
      <*> (o .:? "label")
      <*> (o .:? "token")
      <*> (o .:? "tokenHash")

-- | ToJSON MainGetApiKeysResp
instance A.ToJSON MainGetApiKeysResp where
  toJSON MainGetApiKeysResp {..} =
   _omitNulls
      [ "expiry" .= mainGetApiKeysRespExpiry
      , "label" .= mainGetApiKeysRespLabel
      , "token" .= mainGetApiKeysRespToken
      , "tokenHash" .= mainGetApiKeysRespTokenHash
      ]


-- | Construct a value of type 'MainGetApiKeysResp' (by applying it's required fields, if any)
mkMainGetApiKeysResp
  :: MainGetApiKeysResp
mkMainGetApiKeysResp =
  MainGetApiKeysResp
  { mainGetApiKeysRespExpiry = Nothing
  , mainGetApiKeysRespLabel = Nothing
  , mainGetApiKeysRespToken = Nothing
  , mainGetApiKeysRespTokenHash = Nothing
  }

-- ** MainImportDealBody
-- | MainImportDealBody
data MainImportDealBody = MainImportDealBody
  { mainImportDealBodyColuuid :: !(Maybe Text) -- ^ "coluuid"
  , mainImportDealBodyDealIDs :: !(Maybe [Int]) -- ^ "dealIDs"
  , mainImportDealBodyDir :: !(Maybe Text) -- ^ "dir"
  , mainImportDealBodyName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MainImportDealBody
instance A.FromJSON MainImportDealBody where
  parseJSON = A.withObject "MainImportDealBody" $ \o ->
    MainImportDealBody
      <$> (o .:? "coluuid")
      <*> (o .:? "dealIDs")
      <*> (o .:? "dir")
      <*> (o .:? "name")

-- | ToJSON MainImportDealBody
instance A.ToJSON MainImportDealBody where
  toJSON MainImportDealBody {..} =
   _omitNulls
      [ "coluuid" .= mainImportDealBodyColuuid
      , "dealIDs" .= mainImportDealBodyDealIDs
      , "dir" .= mainImportDealBodyDir
      , "name" .= mainImportDealBodyName
      ]


-- | Construct a value of type 'MainImportDealBody' (by applying it's required fields, if any)
mkMainImportDealBody
  :: MainImportDealBody
mkMainImportDealBody =
  MainImportDealBody
  { mainImportDealBodyColuuid = Nothing
  , mainImportDealBodyDealIDs = Nothing
  , mainImportDealBodyDir = Nothing
  , mainImportDealBodyName = Nothing
  }

-- ** TypesIpfsPin
-- | TypesIpfsPin
data TypesIpfsPin = TypesIpfsPin
  { typesIpfsPinCid :: !(Maybe Text) -- ^ "cid"
  , typesIpfsPinMeta :: !(Maybe A.Value) -- ^ "meta"
  , typesIpfsPinName :: !(Maybe Text) -- ^ "name"
  , typesIpfsPinOrigins :: !(Maybe [Text]) -- ^ "origins"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TypesIpfsPin
instance A.FromJSON TypesIpfsPin where
  parseJSON = A.withObject "TypesIpfsPin" $ \o ->
    TypesIpfsPin
      <$> (o .:? "cid")
      <*> (o .:? "meta")
      <*> (o .:? "name")
      <*> (o .:? "origins")

-- | ToJSON TypesIpfsPin
instance A.ToJSON TypesIpfsPin where
  toJSON TypesIpfsPin {..} =
   _omitNulls
      [ "cid" .= typesIpfsPinCid
      , "meta" .= typesIpfsPinMeta
      , "name" .= typesIpfsPinName
      , "origins" .= typesIpfsPinOrigins
      ]


-- | Construct a value of type 'TypesIpfsPin' (by applying it's required fields, if any)
mkTypesIpfsPin
  :: TypesIpfsPin
mkTypesIpfsPin =
  TypesIpfsPin
  { typesIpfsPinCid = Nothing
  , typesIpfsPinMeta = Nothing
  , typesIpfsPinName = Nothing
  , typesIpfsPinOrigins = Nothing
  }

-- ** UtilContentAddIpfsBody
-- | UtilContentAddIpfsBody
data UtilContentAddIpfsBody = UtilContentAddIpfsBody
  { utilContentAddIpfsBodyColuuid :: !(Maybe Text) -- ^ "coluuid"
  , utilContentAddIpfsBodyDir :: !(Maybe Text) -- ^ "dir"
  , utilContentAddIpfsBodyFilename :: !(Maybe Text) -- ^ "filename"
  , utilContentAddIpfsBodyPeers :: !(Maybe [Text]) -- ^ "peers"
  , utilContentAddIpfsBodyRoot :: !(Maybe Text) -- ^ "root"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UtilContentAddIpfsBody
instance A.FromJSON UtilContentAddIpfsBody where
  parseJSON = A.withObject "UtilContentAddIpfsBody" $ \o ->
    UtilContentAddIpfsBody
      <$> (o .:? "coluuid")
      <*> (o .:? "dir")
      <*> (o .:? "filename")
      <*> (o .:? "peers")
      <*> (o .:? "root")

-- | ToJSON UtilContentAddIpfsBody
instance A.ToJSON UtilContentAddIpfsBody where
  toJSON UtilContentAddIpfsBody {..} =
   _omitNulls
      [ "coluuid" .= utilContentAddIpfsBodyColuuid
      , "dir" .= utilContentAddIpfsBodyDir
      , "filename" .= utilContentAddIpfsBodyFilename
      , "peers" .= utilContentAddIpfsBodyPeers
      , "root" .= utilContentAddIpfsBodyRoot
      ]


-- | Construct a value of type 'UtilContentAddIpfsBody' (by applying it's required fields, if any)
mkUtilContentAddIpfsBody
  :: UtilContentAddIpfsBody
mkUtilContentAddIpfsBody =
  UtilContentAddIpfsBody
  { utilContentAddIpfsBodyColuuid = Nothing
  , utilContentAddIpfsBodyDir = Nothing
  , utilContentAddIpfsBodyFilename = Nothing
  , utilContentAddIpfsBodyPeers = Nothing
  , utilContentAddIpfsBodyRoot = Nothing
  }

-- ** UtilContentAddResponse
-- | UtilContentAddResponse
data UtilContentAddResponse = UtilContentAddResponse
  { utilContentAddResponseCid :: !(Maybe Text) -- ^ "cid"
  , utilContentAddResponseEstuaryId :: !(Maybe Int) -- ^ "estuaryId"
  , utilContentAddResponseProviders :: !(Maybe [Text]) -- ^ "providers"
  , utilContentAddResponseRetrievalUrl :: !(Maybe Text) -- ^ "retrieval_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UtilContentAddResponse
instance A.FromJSON UtilContentAddResponse where
  parseJSON = A.withObject "UtilContentAddResponse" $ \o ->
    UtilContentAddResponse
      <$> (o .:? "cid")
      <*> (o .:? "estuaryId")
      <*> (o .:? "providers")
      <*> (o .:? "retrieval_url")

-- | ToJSON UtilContentAddResponse
instance A.ToJSON UtilContentAddResponse where
  toJSON UtilContentAddResponse {..} =
   _omitNulls
      [ "cid" .= utilContentAddResponseCid
      , "estuaryId" .= utilContentAddResponseEstuaryId
      , "providers" .= utilContentAddResponseProviders
      , "retrieval_url" .= utilContentAddResponseRetrievalUrl
      ]


-- | Construct a value of type 'UtilContentAddResponse' (by applying it's required fields, if any)
mkUtilContentAddResponse
  :: UtilContentAddResponse
mkUtilContentAddResponse =
  UtilContentAddResponse
  { utilContentAddResponseCid = Nothing
  , utilContentAddResponseEstuaryId = Nothing
  , utilContentAddResponseProviders = Nothing
  , utilContentAddResponseRetrievalUrl = Nothing
  }

-- ** UtilContentCreateBody
-- | UtilContentCreateBody
data UtilContentCreateBody = UtilContentCreateBody
  { utilContentCreateBodyColuuid :: !(Maybe Text) -- ^ "coluuid"
  , utilContentCreateBodyDir :: !(Maybe Text) -- ^ "dir"
  , utilContentCreateBodyLocation :: !(Maybe Text) -- ^ "location"
  , utilContentCreateBodyName :: !(Maybe Text) -- ^ "name"
  , utilContentCreateBodyRoot :: !(Maybe Text) -- ^ "root"
  , utilContentCreateBodyType :: !(Maybe Int) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UtilContentCreateBody
instance A.FromJSON UtilContentCreateBody where
  parseJSON = A.withObject "UtilContentCreateBody" $ \o ->
    UtilContentCreateBody
      <$> (o .:? "coluuid")
      <*> (o .:? "dir")
      <*> (o .:? "location")
      <*> (o .:? "name")
      <*> (o .:? "root")
      <*> (o .:? "type")

-- | ToJSON UtilContentCreateBody
instance A.ToJSON UtilContentCreateBody where
  toJSON UtilContentCreateBody {..} =
   _omitNulls
      [ "coluuid" .= utilContentCreateBodyColuuid
      , "dir" .= utilContentCreateBodyDir
      , "location" .= utilContentCreateBodyLocation
      , "name" .= utilContentCreateBodyName
      , "root" .= utilContentCreateBodyRoot
      , "type" .= utilContentCreateBodyType
      ]


-- | Construct a value of type 'UtilContentCreateBody' (by applying it's required fields, if any)
mkUtilContentCreateBody
  :: UtilContentCreateBody
mkUtilContentCreateBody =
  UtilContentCreateBody
  { utilContentCreateBodyColuuid = Nothing
  , utilContentCreateBodyDir = Nothing
  , utilContentCreateBodyLocation = Nothing
  , utilContentCreateBodyName = Nothing
  , utilContentCreateBodyRoot = Nothing
  , utilContentCreateBodyType = Nothing
  }

-- ** UtilHttpError
-- | UtilHttpError
data UtilHttpError = UtilHttpError
  { utilHttpErrorCode :: !(Maybe Int) -- ^ "code"
  , utilHttpErrorDetails :: !(Maybe Text) -- ^ "details"
  , utilHttpErrorReason :: !(Maybe Text) -- ^ "reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UtilHttpError
instance A.FromJSON UtilHttpError where
  parseJSON = A.withObject "UtilHttpError" $ \o ->
    UtilHttpError
      <$> (o .:? "code")
      <*> (o .:? "details")
      <*> (o .:? "reason")

-- | ToJSON UtilHttpError
instance A.ToJSON UtilHttpError where
  toJSON UtilHttpError {..} =
   _omitNulls
      [ "code" .= utilHttpErrorCode
      , "details" .= utilHttpErrorDetails
      , "reason" .= utilHttpErrorReason
      ]


-- | Construct a value of type 'UtilHttpError' (by applying it's required fields, if any)
mkUtilHttpError
  :: UtilHttpError
mkUtilHttpError =
  UtilHttpError
  { utilHttpErrorCode = Nothing
  , utilHttpErrorDetails = Nothing
  , utilHttpErrorReason = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyBearerAuth
data AuthApiKeyBearerAuth =
  AuthApiKeyBearerAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyBearerAuth where
  applyAuthMethod _ a@(AuthApiKeyBearerAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

