/**
 * Estuary API
 * This is the API for the Estuary application.
 *
 * OpenAPI spec version: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { autoinject } from 'aurelia-framework';
import { HttpClient } from 'aurelia-http-client';
import { Api } from './Api';
import { AuthStorage } from './AuthStorage';
import {
  UtilContentCreateBody,
  UtilContentAddIpfsBody,
  UtilContentAddResponse,
  MainImportDealBody,
} from './models';

/**
 * contentAddCarPost - parameters interface
 */
export interface IContentAddCarPostParams {
  body: string;
  ignoreDupes?: string;
  filename?: string;
}

/**
 * contentAddIpfsPost - parameters interface
 */
export interface IContentAddIpfsPostParams {
  body: UtilContentAddIpfsBody;
  ignoreDupes?: string;
}

/**
 * contentAddPost - parameters interface
 */
export interface IContentAddPostParams {
  data: any;
  filename?: string;
  coluuid?: string;
  replication?: number;
  ignoreDupes?: string;
  lazyProvide?: string;
  dir?: string;
}

/**
 * contentAggregatedContentGet - parameters interface
 */
export interface IContentAggregatedContentGetParams {
  content: string;
}

/**
 * contentAllDealsGet - parameters interface
 */
export interface IContentAllDealsGetParams {
  begin: string;
  duration: string;
  all: string;
}

/**
 * contentBwUsageContentGet - parameters interface
 */
export interface IContentBwUsageContentGetParams {
  content: string;
}

/**
 * contentCreatePost - parameters interface
 */
export interface IContentCreatePostParams {
  req: UtilContentCreateBody;
  ignoreDupes?: string;
}

/**
 * contentDealsGet - parameters interface
 */
export interface IContentDealsGetParams {
  limit?: number;
  offset?: number;
}

/**
 * contentEnsureReplicationDatacidGet - parameters interface
 */
export interface IContentEnsureReplicationDatacidGetParams {
  datacid: string;
}

/**
 * contentFailuresContentGet - parameters interface
 */
export interface IContentFailuresContentGetParams {
  content: string;
}

/**
 * contentIdGet - parameters interface
 */
export interface IContentIdGetParams {
  id: number;
}

/**
 * contentImportdealPost - parameters interface
 */
export interface IContentImportdealPostParams {
  body: MainImportDealBody;
}

/**
 * contentListGet - parameters interface
 */
export interface IContentListGetParams {
}

/**
 * contentReadContGet - parameters interface
 */
export interface IContentReadContGetParams {
  cont: string;
}

/**
 * contentStagingZonesGet - parameters interface
 */
export interface IContentStagingZonesGetParams {
}

/**
 * contentStatsGet - parameters interface
 */
export interface IContentStatsGetParams {
  limit: string;
  offset: string;
}

/**
 * contentStatusIdGet - parameters interface
 */
export interface IContentStatusIdGetParams {
  id: number;
}

/**
 * ContentApi - API class
 */
@autoinject()
export class ContentApi extends Api {

  /**
   * Creates a new ContentApi class.
   *
   * @param httpClient The Aurelia HTTP client to be injected.
   * @param authStorage A storage for authentication data.
   */
  constructor(httpClient: HttpClient, authStorage: AuthStorage) {
    super(httpClient, authStorage);
  }

  /**
   * Add Car object
   * This endpoint is used to add a car object to the network. The object can be a file or a directory.
   * @param params.body Car
   * @param params.ignoreDupes Ignore Dupes
   * @param params.filename Filename
   */
  async contentAddCarPost(params: IContentAddCarPostParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentAddCarPost', params, 'body');

    // Create URL to call
    const url = `${this.basePath}/content/add-car`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'ignore-dupes': params['ignoreDupes'],
        'filename': params['filename'],
      })
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['body'] || {}))

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Add IPFS object
   * This endpoint is used to add an IPFS object to the network. The object can be a file or a directory.
   * @param params.body IPFS Body
   * @param params.ignoreDupes Ignore Dupes
   */
  async contentAddIpfsPost(params: IContentAddIpfsPostParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentAddIpfsPost', params, 'body');

    // Create URL to call
    const url = `${this.basePath}/content/add-ipfs`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'ignore-dupes': params['ignoreDupes'],
      })
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['body'] || {}))

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Add new content
   * This endpoint is used to upload new content.
   * @param params.data File to upload
   * @param params.filename Filenam to use for upload
   * @param params.coluuid Collection UUID
   * @param params.replication Replication value
   * @param params.ignoreDupes Ignore Dupes true/false
   * @param params.lazyProvide Lazy Provide true/false
   * @param params.dir Directory
   */
  async contentAddPost(params: IContentAddPostParams): Promise<UtilContentAddResponse> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentAddPost', params, 'data');

    // Create URL to call
    const url = `${this.basePath}/content/add`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'coluuid': params['coluuid'],
        'replication': params['replication'],
        'ignore-dupes': params['ignoreDupes'],
        'lazy-provide': params['lazyProvide'],
        'dir': params['dir'],
      })
      // Encode form parameters
      .withHeader('content-type', 'application/x-www-form-urlencoded')
      .withContent(this.queryString({ 
        'data': params['data'],
        'filename': params['filename'],
      }))

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get aggregated content stats
   * This endpoint returns aggregated content stats
   * @param params.content Content ID
   */
  async contentAggregatedContentGet(params: IContentAggregatedContentGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentAggregatedContentGet', params, 'content');

    // Create URL to call
    const url = `${this.basePath}/content/aggregated/{content}`
      .replace(`{${'content'}}`, encodeURIComponent(`${params['content']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get all deals for a user
   * This endpoint is used to get all deals for a user
   * @param params.begin Begin
   * @param params.duration Duration
   * @param params.all All
   */
  async contentAllDealsGet(params: IContentAllDealsGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentAllDealsGet', params, 'begin');
    this.ensureParamIsSet('contentAllDealsGet', params, 'duration');
    this.ensureParamIsSet('contentAllDealsGet', params, 'all');

    // Create URL to call
    const url = `${this.basePath}/content/all-deals`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'begin': params['begin'],
        'duration': params['duration'],
        'all': params['all'],
      })

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get content bandwidth
   * This endpoint returns content bandwidth
   * @param params.content Content ID
   */
  async contentBwUsageContentGet(params: IContentBwUsageContentGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentBwUsageContentGet', params, 'content');

    // Create URL to call
    const url = `${this.basePath}/content/bw-usage/{content}`
      .replace(`{${'content'}}`, encodeURIComponent(`${params['content']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Add a new content
   * This endpoint adds a new content
   * @param params.req Content
   * @param params.ignoreDupes Ignore Dupes
   */
  async contentCreatePost(params: IContentCreatePostParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentCreatePost', params, 'req');

    // Create URL to call
    const url = `${this.basePath}/content/create`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Set query parameters
      .withParams({ 
        'ignore-dupes': params['ignoreDupes'],
      })
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['req'] || {}))

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Content with deals
   * This endpoint lists all content with deals
   * @param params.limit Limit
   * @param params.offset Offset
   */
  async contentDealsGet(params: IContentDealsGetParams): Promise<string> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/content/deals`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'limit': params['limit'],
        'offset': params['offset'],
      })

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Ensure Replication
   * This endpoint ensures that the content is replicated to the specified number of providers
   * @param params.datacid Data CID
   */
  async contentEnsureReplicationDatacidGet(params: IContentEnsureReplicationDatacidGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentEnsureReplicationDatacidGet', params, 'datacid');

    // Create URL to call
    const url = `${this.basePath}/content/ensure-replication/{datacid}`
      .replace(`{${'datacid'}}`, encodeURIComponent(`${params['datacid']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * List all failures for a content
   * This endpoint returns all failures for a content
   * @param params.content Content ID
   */
  async contentFailuresContentGet(params: IContentFailuresContentGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentFailuresContentGet', params, 'content');

    // Create URL to call
    const url = `${this.basePath}/content/failures/{content}`
      .replace(`{${'content'}}`, encodeURIComponent(`${params['content']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Content
   * This endpoint returns a content by its ID
   * @param params.id Content ID
   */
  async contentIdGet(params: IContentIdGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentIdGet', params, 'id');

    // Create URL to call
    const url = `${this.basePath}/content/{id}`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Import a deal
   * This endpoint imports a deal into the shuttle.
   * @param params.body Import a deal
   */
  async contentImportdealPost(params: IContentImportdealPostParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentImportdealPost', params, 'body');

    // Create URL to call
    const url = `${this.basePath}/content/importdeal`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['body'] || {}))

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * List all pinned content
   * This endpoint lists all content
   */
  async contentListGet(): Promise<string> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/content/list`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Read content
   * This endpoint reads content from the blockstore
   * @param params.cont CID
   */
  async contentReadContGet(params: IContentReadContGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentReadContGet', params, 'cont');

    // Create URL to call
    const url = `${this.basePath}/content/read/{cont}`
      .replace(`{${'cont'}}`, encodeURIComponent(`${params['cont']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get staging zone for user
   * This endpoint is used to get staging zone for user.
   */
  async contentStagingZonesGet(): Promise<string> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/content/staging-zones`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get content statistics
   * This endpoint is used to get content statistics. Every content stored in the network (estuary) is tracked by a unique ID which can be used to get information about the content. This endpoint will allow the consumer to get the collected stats of a conten
   * @param params.limit limit
   * @param params.offset offset
   */
  async contentStatsGet(params: IContentStatsGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentStatsGet', params, 'limit');
    this.ensureParamIsSet('contentStatsGet', params, 'offset');

    // Create URL to call
    const url = `${this.basePath}/content/stats`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'limit': params['limit'],
        'offset': params['offset'],
      })

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Content Status
   * This endpoint returns the status of a content
   * @param params.id Content ID
   */
  async contentStatusIdGet(params: IContentStatusIdGetParams): Promise<string> {
    // Verify required parameters are set
    this.ensureParamIsSet('contentStatusIdGet', params, 'id');

    // Create URL to call
    const url = `${this.basePath}/content/status/{id}`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'bearerAuth' required
      .withHeader('Authorization', this.authStorage.getbearerAuth())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

}

