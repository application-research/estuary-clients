/**
 * Estuary API
 * This is the API for the Estuary application.
 *
 * OpenAPI spec version: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.ContentAddIpfsBody
import io.swagger.client.model.ContentAddResponse
import java.io.File
import io.swagger.client.model.ImportDealBody
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class ContentApi(
  val defBasePath: String = "https://api.estuary.tech",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new ContentApiAsyncHelper(client, config)

  /**
   * Add Car object
   * This endpoint is used to add a car object to the network. The object can be a file or a directory.
   *
   * @param body Car 
   * @param filename Filename (optional)
   * @param commp Commp (optional)
   * @param size Size (optional)
   * @return void
   */
  def contentAddCarPost(body: String, filename: Option[String] = None, commp: Option[String] = None, size: Option[String] = None) = {
    val await = Try(Await.result(contentAddCarPostAsync(body, filename, commp, size), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add Car object asynchronously
   * This endpoint is used to add a car object to the network. The object can be a file or a directory.
   *
   * @param body Car 
   * @param filename Filename (optional)
   * @param commp Commp (optional)
   * @param size Size (optional)
   * @return Future(void)
   */
  def contentAddCarPostAsync(body: String, filename: Option[String] = None, commp: Option[String] = None, size: Option[String] = None) = {
      helper.contentAddCarPost(body, filename, commp, size)
  }

  /**
   * Add IPFS object
   * This endpoint is used to add an IPFS object to the network. The object can be a file or a directory.
   *
   * @param body IPFS Body 
   * @return void
   */
  def contentAddIpfsPost(body: ContentAddIpfsBody) = {
    val await = Try(Await.result(contentAddIpfsPostAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add IPFS object asynchronously
   * This endpoint is used to add an IPFS object to the network. The object can be a file or a directory.
   *
   * @param body IPFS Body 
   * @return Future(void)
   */
  def contentAddIpfsPostAsync(body: ContentAddIpfsBody) = {
      helper.contentAddIpfsPost(body)
  }

  /**
   * Add new content
   * This endpoint is used to upload new content.
   *
   * @param file File to upload 
   * @param coluuid Collection UUID 
   * @param dir Directory 
   * @return ContentAddResponse
   */
  def contentAddPost(file: File, coluuid: String, dir: String): Option[ContentAddResponse] = {
    val await = Try(Await.result(contentAddPostAsync(file, coluuid, dir), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add new content asynchronously
   * This endpoint is used to upload new content.
   *
   * @param file File to upload 
   * @param coluuid Collection UUID 
   * @param dir Directory 
   * @return Future(ContentAddResponse)
   */
  def contentAddPostAsync(file: File, coluuid: String, dir: String): Future[ContentAddResponse] = {
      helper.contentAddPost(file, coluuid, dir)
  }

  /**
   * Get aggregated content stats
   * This endpoint returns aggregated content stats
   *
   * @param content Content ID 
   * @return String
   */
  def contentAggregatedContentGet(content: String): Option[String] = {
    val await = Try(Await.result(contentAggregatedContentGetAsync(content), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get aggregated content stats asynchronously
   * This endpoint returns aggregated content stats
   *
   * @param content Content ID 
   * @return Future(String)
   */
  def contentAggregatedContentGetAsync(content: String): Future[String] = {
      helper.contentAggregatedContentGet(content)
  }

  /**
   * Get all deals for a user
   * This endpoint is used to get all deals for a user
   *
   * @param begin Begin 
   * @param duration Duration 
   * @param all All 
   * @return void
   */
  def contentAllDealsGet(begin: String, duration: String, all: String) = {
    val await = Try(Await.result(contentAllDealsGetAsync(begin, duration, all), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all deals for a user asynchronously
   * This endpoint is used to get all deals for a user
   *
   * @param begin Begin 
   * @param duration Duration 
   * @param all All 
   * @return Future(void)
   */
  def contentAllDealsGetAsync(begin: String, duration: String, all: String) = {
      helper.contentAllDealsGet(begin, duration, all)
  }

  /**
   * Get content bandwidth
   * This endpoint returns content bandwidth
   *
   * @param content Content ID 
   * @return void
   */
  def contentBwUsageContentGet(content: String) = {
    val await = Try(Await.result(contentBwUsageContentGetAsync(content), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get content bandwidth asynchronously
   * This endpoint returns content bandwidth
   *
   * @param content Content ID 
   * @return Future(void)
   */
  def contentBwUsageContentGetAsync(content: String) = {
      helper.contentBwUsageContentGet(content)
  }

  /**
   * Add a new content
   * This endpoint adds a new content
   *
   * @param body Content 
   * @return void
   */
  def contentCreatePost(body: String) = {
    val await = Try(Await.result(contentCreatePostAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a new content asynchronously
   * This endpoint adds a new content
   *
   * @param body Content 
   * @return Future(void)
   */
  def contentCreatePostAsync(body: String) = {
      helper.contentCreatePost(body)
  }

  /**
   * Content with deals
   * This endpoint lists all content with deals
   *
   * @param limit Limit (optional)
   * @param offset Offset (optional)
   * @return void
   */
  def contentDealsGet(limit: Option[Integer] = None, offset: Option[Integer] = None) = {
    val await = Try(Await.result(contentDealsGetAsync(limit, offset), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Content with deals asynchronously
   * This endpoint lists all content with deals
   *
   * @param limit Limit (optional)
   * @param offset Offset (optional)
   * @return Future(void)
   */
  def contentDealsGetAsync(limit: Option[Integer] = None, offset: Option[Integer] = None) = {
      helper.contentDealsGet(limit, offset)
  }

  /**
   * Ensure Replication
   * This endpoint ensures that the content is replicated to the specified number of providers
   *
   * @param datacid Data CID 
   * @return void
   */
  def contentEnsureReplicationDatacidGet(datacid: String) = {
    val await = Try(Await.result(contentEnsureReplicationDatacidGetAsync(datacid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Ensure Replication asynchronously
   * This endpoint ensures that the content is replicated to the specified number of providers
   *
   * @param datacid Data CID 
   * @return Future(void)
   */
  def contentEnsureReplicationDatacidGetAsync(datacid: String) = {
      helper.contentEnsureReplicationDatacidGet(datacid)
  }

  /**
   * List all failures for a content
   * This endpoint returns all failures for a content
   *
   * @param content Content ID 
   * @return String
   */
  def contentFailuresContentGet(content: String): Option[String] = {
    val await = Try(Await.result(contentFailuresContentGetAsync(content), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List all failures for a content asynchronously
   * This endpoint returns all failures for a content
   *
   * @param content Content ID 
   * @return Future(String)
   */
  def contentFailuresContentGetAsync(content: String): Future[String] = {
      helper.contentFailuresContentGet(content)
  }

  /**
   * Import a deal
   * This endpoint imports a deal into the shuttle.
   *
   * @param body Import a deal 
   * @return void
   */
  def contentImportdealPost(body: ImportDealBody) = {
    val await = Try(Await.result(contentImportdealPostAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Import a deal asynchronously
   * This endpoint imports a deal into the shuttle.
   *
   * @param body Import a deal 
   * @return Future(void)
   */
  def contentImportdealPostAsync(body: ImportDealBody) = {
      helper.contentImportdealPost(body)
  }

  /**
   * List all pinned content
   * This endpoint lists all content
   *
   * @return List[String]
   */
  def contentListGet(): Option[List[String]] = {
    val await = Try(Await.result(contentListGetAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List all pinned content asynchronously
   * This endpoint lists all content
   *
   * @return Future(List[String])
   */
  def contentListGetAsync(): Future[List[String]] = {
      helper.contentListGet()
  }

  /**
   * Read content
   * This endpoint reads content from the blockstore
   *
   * @param cont CID 
   * @return void
   */
  def contentReadContGet(cont: String) = {
    val await = Try(Await.result(contentReadContGetAsync(cont), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Read content asynchronously
   * This endpoint reads content from the blockstore
   *
   * @param cont CID 
   * @return Future(void)
   */
  def contentReadContGetAsync(cont: String) = {
      helper.contentReadContGet(cont)
  }

  /**
   * Get staging zone for user
   * This endpoint is used to get staging zone for user.
   *
   * @return void
   */
  def contentStagingZonesGet() = {
    val await = Try(Await.result(contentStagingZonesGetAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get staging zone for user asynchronously
   * This endpoint is used to get staging zone for user.
   *
   * @return Future(void)
   */
  def contentStagingZonesGetAsync() = {
      helper.contentStagingZonesGet()
  }

  /**
   * Get content statistics
   * This endpoint is used to get content statistics. Every content stored in the network (estuary) is tracked by a unique ID which can be used to get information about the content. This endpoint will allow the consumer to get the collected stats of a conten
   *
   * @param limit limit 
   * @return void
   */
  def contentStatsGet(limit: String) = {
    val await = Try(Await.result(contentStatsGetAsync(limit), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get content statistics asynchronously
   * This endpoint is used to get content statistics. Every content stored in the network (estuary) is tracked by a unique ID which can be used to get information about the content. This endpoint will allow the consumer to get the collected stats of a conten
   *
   * @param limit limit 
   * @return Future(void)
   */
  def contentStatsGetAsync(limit: String) = {
      helper.contentStatsGet(limit)
  }

  /**
   * Content Status
   * This endpoint returns the status of a content
   *
   * @param id Content ID 
   * @return void
   */
  def contentStatusIdGet(id: Integer) = {
    val await = Try(Await.result(contentStatusIdGetAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Content Status asynchronously
   * This endpoint returns the status of a content
   *
   * @param id Content ID 
   * @return Future(void)
   */
  def contentStatusIdGetAsync(id: Integer) = {
      helper.contentStatusIdGet(id)
  }

}

class ContentApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def contentAddCarPost(body: String,
    filename: Option[String] = None,
    commp: Option[String] = None,
    size: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[String]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/add-car"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling ContentApi->contentAddCarPost")

    filename match {
      case Some(param) => queryParams += "filename" -> param.toString
      case _ => queryParams
    }
    commp match {
      case Some(param) => queryParams += "commp" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentAddIpfsPost(body: ContentAddIpfsBody)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[ContentAddIpfsBody]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/add-ipfs"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling ContentApi->contentAddIpfsPost")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentAddPost(file: File,
    coluuid: String,
    dir: String)(implicit reader: ClientResponseReader[ContentAddResponse]): Future[ContentAddResponse] = {
    // create path and map variables
    val path = (addFmt("/content/add")
      replaceAll("\\{" + "coluuid" + "\\}", coluuid.toString)
      replaceAll("\\{" + "dir" + "\\}", dir.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (file == null) throw new Exception("Missing required parameter 'file' when calling ContentApi->contentAddPost")
    if (coluuid == null) throw new Exception("Missing required parameter 'coluuid' when calling ContentApi->contentAddPost")

    if (dir == null) throw new Exception("Missing required parameter 'dir' when calling ContentApi->contentAddPost")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentAggregatedContentGet(content: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/content/aggregated/{content}")
      replaceAll("\\{" + "content" + "\\}", content.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (content == null) throw new Exception("Missing required parameter 'content' when calling ContentApi->contentAggregatedContentGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentAllDealsGet(begin: String,
    duration: String,
    all: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/all-deals"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (begin == null) throw new Exception("Missing required parameter 'begin' when calling ContentApi->contentAllDealsGet")

    if (duration == null) throw new Exception("Missing required parameter 'duration' when calling ContentApi->contentAllDealsGet")

    if (all == null) throw new Exception("Missing required parameter 'all' when calling ContentApi->contentAllDealsGet")

    queryParams += "begin" -> begin.toString
    queryParams += "duration" -> duration.toString
    queryParams += "all" -> all.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentBwUsageContentGet(content: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/bw-usage/{content}")
      replaceAll("\\{" + "content" + "\\}", content.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (content == null) throw new Exception("Missing required parameter 'content' when calling ContentApi->contentBwUsageContentGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentCreatePost(body: String)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[String]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/create"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling ContentApi->contentCreatePost")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentDealsGet(limit: Option[Integer] = None,
    offset: Option[Integer] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/deals"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentEnsureReplicationDatacidGet(datacid: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/ensure-replication/{datacid}")
      replaceAll("\\{" + "datacid" + "\\}", datacid.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (datacid == null) throw new Exception("Missing required parameter 'datacid' when calling ContentApi->contentEnsureReplicationDatacidGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentFailuresContentGet(content: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/content/failures/{content}")
      replaceAll("\\{" + "content" + "\\}", content.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (content == null) throw new Exception("Missing required parameter 'content' when calling ContentApi->contentFailuresContentGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentImportdealPost(body: ImportDealBody)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[ImportDealBody]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/importdeal"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling ContentApi->contentImportdealPost")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentListGet()(implicit reader: ClientResponseReader[List[String]]): Future[List[String]] = {
    // create path and map variables
    val path = (addFmt("/content/list"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentReadContGet(cont: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/read/{cont}")
      replaceAll("\\{" + "cont" + "\\}", cont.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (cont == null) throw new Exception("Missing required parameter 'cont' when calling ContentApi->contentReadContGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentStagingZonesGet()(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/staging-zones"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentStatsGet(limit: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/stats")
      replaceAll("\\{" + "limit" + "\\}", limit.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (limit == null) throw new Exception("Missing required parameter 'limit' when calling ContentApi->contentStatsGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def contentStatusIdGet(id: Integer)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/content/status/{id}")
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
