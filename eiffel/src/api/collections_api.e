note
 description:"[
		Estuary API
 		This is the API for the Estuary application.
  		OpenAPI spec version: 0.0.0
 	    

  	NOTE: This class is auto generated by the swagger code generator program.

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel swagger codegen", "src=https://github.com/swagger-api/swagger-codegen.git", "protocol=uri"

class
	COLLECTIONS_API

inherit

    API_I


feature -- API Access


	collections_coluuid_commit_post (coluuid: STRING_32): detachable STRING_32
			-- Produce a CID of the collection contents
			-- This endpoint is used to save the contents in a collection, producing a top-level CID that references all the current CIDs in the collection.
			-- 
			-- argument: coluuid coluuid (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/collections/{coluuid}/commit"
			l_path.replace_substring_all ("{"+"coluuid"+"}", api_client.url_encode (coluuid.out))


			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"bearerAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	collections_coluuid_contents_delete (coluuid: STRING_32; contentid: STRING_32; body: MAIN_DELETE_CONTENT_FROM_COLLECTION_BODY): detachable STRING_32
			-- Deletes a content from a collection
			-- This endpoint is used to delete an existing content from an existing collection. If two or more files with the same contentid exist in the collection, delete the one in the specified path
			-- 
			-- argument: coluuid Collection ID (required)
			-- 
			-- argument: contentid Content ID (required)
			-- 
			-- argument: body Variable to use when filtering for files (must be either &#39;path&#39; or &#39;content_id&#39;) (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(body)
			l_path := "/collections/{coluuid}/contents"
			l_path.replace_substring_all ("{"+"coluuid"+"}", api_client.url_encode (coluuid.out))
			l_path.replace_substring_all ("{"+"contentid"+"}", api_client.url_encode (contentid.out))


			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"bearerAuth">>)
			l_response := api_client.call_api (l_path, "Delete", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	collections_coluuid_delete (coluuid: STRING_32): detachable STRING_32
			-- Deletes a collection
			-- This endpoint is used to delete an existing collection.
			-- 
			-- argument: coluuid Collection ID (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/collections/{coluuid}"
			l_path.replace_substring_all ("{"+"coluuid"+"}", api_client.url_encode (coluuid.out))


			if attached {STRING} api_client.select_header_accept (<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"bearerAuth">>)
			l_response := api_client.call_api (l_path, "Delete", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	collections_coluuid_get (coluuid: STRING_32; dir: STRING_32): detachable STRING_32
			-- Get contents in a collection
			-- This endpoint is used to get contents in a collection. If no colpath query param is passed
			-- 
			-- argument: coluuid coluuid (required)
			-- 
			-- argument: dir Directory (optional)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/collections/{coluuid}"
			l_path.replace_substring_all ("{"+"coluuid"+"}", api_client.url_encode (coluuid.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "dir", dir));


			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"bearerAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	collections_coluuid_post (coluuid: STRING_32; content_ids: LIST [INTEGER_32]): detachable STRING_32
			-- Add contents to a collection
			-- This endpoint adds already-pinned contents (that have ContentIDs) to a collection.
			-- 
			-- argument: coluuid coluuid (required)
			-- 
			-- argument: content_ids Content IDs to add to collection (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(content_ids)
			l_path := "/collections/{coluuid}"
			l_path.replace_substring_all ("{"+"coluuid"+"}", api_client.url_encode (coluuid.out))


			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<"application/json">>),"Content-Type")
			l_request.set_auth_names (<<"bearerAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	collections_fs_add_post (coluuid: STRING_32; content: STRING_32; path: STRING_32): detachable STRING_32
			-- Add a file to a collection
			-- This endpoint adds a file to a collection
			-- 
			-- argument: coluuid Collection ID (required)
			-- 
			-- argument: content Content (required)
			-- 
			-- argument: path Path to file (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/collections/fs/add"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "coluuid", coluuid));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "content", content));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "path", path));


			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"bearerAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	collections_get : detachable LIST [LIST [COLLECTIONS_COLLECTION]]
			-- List all collections
			-- This endpoint is used to list all collections. Whenever a user logs on estuary, it will list all collections that the user has access to. This endpoint provides a way to list all collections to the user.
			-- 
			-- 
			-- Result LIST [LIST [COLLECTIONS_COLLECTION]]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/collections/"


			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"bearerAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [LIST [COLLECTIONS_COLLECTION]] } l_response.data ({ LIST [LIST [COLLECTIONS_COLLECTION]] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	collections_post (body: MAIN_CREATE_COLLECTION_BODY): detachable COLLECTIONS_COLLECTION
			-- Create a new collection
			-- This endpoint is used to create a new collection. A collection is a representaion of a group of objects added on the estuary. This endpoint can be used to create a new collection.
			-- 
			-- argument: body Collection name and description (required)
			-- 
			-- 
			-- Result COLLECTIONS_COLLECTION
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(body)
			l_path := "/collections/"


			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<"bearerAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { COLLECTIONS_COLLECTION } l_response.data ({ COLLECTIONS_COLLECTION }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	


end
